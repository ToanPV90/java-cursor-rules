<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {
		margin: 0;
		padding: 4px 8px 24px;
		background-color: #ffffff;
		overflow-y: scroll
	}
	h1 {
		margin: 5px 0 0 0;
		font-size: 18px;
		font-weight: normal;
		text-align: center
	}
	header {
		margin: -24px 0 5px 0;
		line-height: 24px
	}
	button {
		font: 12px sans-serif;
		cursor: pointer
	}
	p {
		margin: 5px 0 5px 0
	}
	a {
		color: #0366d6
	}
	#hl {
		position: absolute;
		display: none;
		overflow: hidden;
		white-space: nowrap;
		pointer-events: none;
		background-color: #ffffe0;
		outline: 1px solid #ffc000;
		height: 15px
	}
	#preview_wrapper {
		position: absolute;
		display: none;
		background-color: #ffffe0;
		outline: 1px solid #ffc000;
		pointer-events: none;
	}
	#hl span {
		padding: 0 3px 0 3px
	}
	#status {
		overflow: hidden;
		white-space: nowrap
	}
	#match {
		overflow: hidden;
		white-space: nowrap;
		display: none;
		float: right;
		text-align: right
	}
	#reset {
		cursor: pointer
	}
	#canvas {
		width: 100%;
		height: 300px;
	}
	.selectionPart {
		position: absolute;
		display: none;
		pointer-events: none;
		box-sizing: border-box;
	}
	.sel {
		background-color: #dada0040
	}
	.act {
		background-color: #00da0040
	}
	.dif {
		background-color: #00dada40
	}
	.top {
		border-top: .1px solid #000
	}
	.left {
		border-left: .1px solid #000
	}
	.bottom {
		border-bottom: .1px solid #000
	}
	.right {
		border-right: .1px solid #000
	}
	#info-tooltip {
		display: none;
		position: absolute;
		top: 10px;
		right: 48px;
		width: 204px;
		border: 1px solid #666666;
		background: #ffffe0;
		border-radius: 8px;
		padding: 4px
	}
	#heatmap-height-line {
		text-decoration: #0366d6 dashed underline;
		cursor: pointer;
		font-family: monospace
	}
	#heatmap-info {
		cursor: help
	}
	#heatmap-info:hover ~ #info-tooltip {
		display: block
	}
	.toolbarIcon {
		width: 24px;
		height: 24px;
		margin-top: 4px;
		margin-bottom: 4px;
		display: flex;
		justify-content: center;
		align-items: center;
	}
	.toolbarSelected {
		background-color: #cccccc;
		outline: 1px solid #999999;
		border-radius: 4px;
	}
	.toolbarIcon:hover {
		background-color: #ffffe0;
		outline: 1px solid #ffc000;
		border-radius: 4px;
	}
	.bordered {
		outline: 1px solid #999999;
	}
	.colortip {
		width: 100px;
		box-sizing: border-box;
		padding: 4px;
		background: linear-gradient(var(--c1), var(--c2))
	}
	.status {
		position: fixed;
		bottom: 0;
		padding: 2px 4px;
		background-color: #ffffe0;
		border-top: 1px solid #ffc000;
		border-left: 1px solid #ffc000;
		border-right: 1px solid #ffc000;
	}
</style>
</head>
<body style='font: 12px Verdana, sans-serif'>
<div class='bordered' style="display: flex">
	<div class='bordered' style="width: 20px; margin-right: 1px; padding: 2px; float: left; background-color: #efefef; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none">
		<pre id="heatmap-height-line"> 1 sec : 20 ms </pre>
	</div>

	<div id='heatmap-canvas-container' style="width: 100%; position: relative" autofocus>
		<div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%; font-size: 0; padding-bottom: 1px'>
			<canvas id='heatmap-canvas' style='height: 314px'></canvas>
		</div>

		<div id='middleActive' class='selectionPart top bottom act'><span></span></div>
		<div id='leftActive' class='selectionPart top left bottom act'><span></span></div>
		<div id='rightActive' class='selectionPart top right bottom act'><span></span></div>
		<div id='leftMiddleActive' class='selectionPart right'><span></span></div>
		<div id='rightMiddleActive' class='selectionPart left'><span></span></div>

		<div id='middleSelection' class='selectionPart top bottom sel'><span></span></div>
		<div id='leftSelection' class='selectionPart top left bottom sel'><span></span></div>
		<div id='rightSelection' class='selectionPart top right bottom sel'><span></span></div>
		<div id='leftMiddleSelection' class='selectionPart right'><span></span></div>
		<div id='rightMiddleSelection' class='selectionPart left'><span></span></div>

		<div id='middleDiff' class='selectionPart top bottom dif'><span></span></div>
		<div id='leftDiff' class='selectionPart top left bottom dif'><span></span></div>
		<div id='rightDiff' class='selectionPart top right bottom dif'><span></span></div>
		<div id='leftMiddleDiff' class='selectionPart right'><span></span></div>
		<div id='rightMiddleDiff' class='selectionPart left'><span></span></div>
	</div>

	<div class='bordered' style="user-select: none; background-color: #efefef; padding: 2px; margin-left: 1px">
		<div id="heatmap-info" class="toolbarIcon"><svg height="20px" width="20px" viewBox="0 0 392.598 392.598"><path style="fill:#FFFFFF;" d="M274.457,148.234c0.194,17.131-5.236,33.358-15.515,46.933c-23.984,32-36.784,68.331-36.784,104.921 v1.164h-51.911c-0.065-37.107-12.929-73.956-37.107-106.537c-12.735-15.386-17.455-32.065-15.321-49.842 c5.624-45.834,39.822-70.917,74.343-74.925C237.026,67.879,274.457,103.693,274.457,148.234z"></path><rect style="fill:#40b2ff;" x="170.311" y="323.038" width="51.846" height="47.774"></rect><path style="fill:#ff8d40;" d="M196.299,91.604c-0.905,0-1.939,0-2.844,0.065c-17.842,0.84-33.681,10.279-43.442,24.178h42.408 c6.012,0,10.925,4.848,10.925,10.925s-4.848,10.925-10.925,10.925h-51.588c-0.453,2.651-0.84,5.301-1.034,8.016 c-0.259,4.719,0.129,9.244,1.099,13.77h25.988c6.012,0,10.925,4.848,10.925,10.925c0,6.012-4.848,10.925-10.925,10.925h-16.356 c0.065,0.129,0.129,0.323,0.323,0.388c22.238,30.061,35.943,63.418,40.016,97.681h10.796c3.943-34.263,17.519-67.556,39.952-97.358 c7.37-9.826,11.313-21.463,11.313-33.875C252.865,117.075,227.523,91.604,196.299,91.604z"></path><path style="fill:#004d80;" d="M196.299,36.137c6.012,0,10.925-4.848,10.925-10.925V10.925C207.224,4.913,202.376,0,196.299,0 c-6.012,0-10.925,4.848-10.925,10.925v14.287C185.374,31.289,190.287,36.137,196.299,36.137z"></path> <path style="fill:#004d80;" d="M333.543,137.309h-14.287c-6.012,0-10.925,4.848-10.925,10.925c0,6.012,4.849,10.925,10.925,10.925 h14.287c6.012,0,10.925-4.848,10.925-10.925S339.556,137.309,333.543,137.309z"></path> <path style="fill:#004d80;" d="M73.277,137.309H59.055c-6.012,0-10.925,4.848-10.925,10.925c0,6.012,4.848,10.925,10.925,10.925 h14.287c6.012,0,10.925-4.848,10.925-10.925C84.202,142.158,79.289,137.309,73.277,137.309z"></path> <path style="fill:#004d80;" d="M285.64,43.507l-10.15,10.149c-4.267,4.267-4.267,11.119,0,15.45c4.267,4.267,11.119,4.267,15.451,0 l10.15-10.149c4.267-4.267,4.267-11.119,0-15.451C296.824,39.176,289.907,39.176,285.64,43.507z"></path> <path style="fill:#004d80;" d="M101.657,227.491l-10.085,10.02c-4.267,4.267-4.267,11.119,0,15.451 c4.267,4.331,11.119,4.267,15.451,0l10.02-10.02c4.267-4.267,4.267-11.119,0-15.451 C112.776,223.224,105.859,223.224,101.657,227.491z"></path> <path style="fill:#004d80;" d="M290.941,227.491c-4.267-4.267-11.119-4.267-15.451,0c-4.267,4.267-4.267,11.119,0,15.451 l10.15,10.149c4.267,4.267,11.119,4.267,15.451,0s4.267-11.119,0-15.451L290.941,227.491z"></path> <path style="fill:#004d80;" d="M101.657,68.978c4.267,4.267,11.119,4.267,15.451,0c4.267-4.267,4.267-11.119,0-15.451l-10.02-10.02 c-4.267-4.267-11.119-4.267-15.451,0c-4.267,4.267-4.267,11.119,0,15.451L101.657,68.978z"></path> <path style="fill:#004d80;" d="M191.257,48.097c-51.2,2.457-92.962,44.606-95.095,95.806c-1.034,23.208,5.818,45.188,19.523,63.741 c21.463,28.962,32.84,61.414,32.84,93.996v80.032c0,6.012,4.848,10.925,10.925,10.925h73.632c6.012,0,10.925-4.848,10.925-10.925 l0.065-81.584c0-31.935,11.184-63.677,32.388-91.798c13.123-17.455,20.04-38.141,20.04-60.057 C296.436,91.345,248.921,45.253,191.257,48.097z M222.093,370.812h-51.846v-47.774h51.846L222.093,370.812L222.093,370.812z M258.941,195.168c-23.984,32-36.784,68.331-36.784,104.921v1.164h-51.911c-0.065-37.107-12.929-73.956-37.107-106.537 c-12.735-15.386-17.455-32.065-15.321-49.842c5.624-45.834,39.822-70.917,74.343-74.925c44.865-2.069,82.295,33.745,82.295,78.287 C274.651,165.366,269.22,181.592,258.941,195.168z"></path></svg></div>
		<div id="search" class="toolbarIcon" title="Search by Regex [Ctrl + F]"><svg height="20px" width="20px" viewBox="-39.26 -39.26 471.13 471.13" xml:space="preserve" fill="#000000" stroke="#000000" stroke-width="0.00392609"><path style="fill:#FFFFFF;" d="M273.713,147.774c0,69.495-56.501,125.931-125.931,125.931c-69.495,0-125.931-56.501-125.931-125.931 c0-69.495,56.501-125.931,125.931-125.931C217.212,21.843,273.713,78.344,273.713,147.774z"></path><path style="fill:#40b2ff;" d="M370.747,348.695c0,1.422-1.616,6.271-7.176,12.283c-6.206,6.659-12.477,9.762-14.739,9.762h-0.065 c-19.459-1.616-61.996-43.184-109.576-106.796c0-0.065,0-0.065,0-0.129c9.18-7.24,17.455-15.515,24.63-24.63 c0.065,0,0.065,0,0.129,0C327.564,286.699,369.131,329.301,370.747,348.695z"></path><path style="fill:#ff8d40;" d="M208.679,86.877l-14.481,14.481c-17.131,17.131-46.545,5.042-46.545-19.265V61.6 c-49.002,0-88.372,40.792-86.109,90.246c2.004,43.895,38.141,80.032,82.036,82.036c49.455,2.263,90.246-37.172,90.246-86.109 C233.956,124.049,224.323,102.522,208.679,86.877z"></path><path style="fill:#004d80;" d="M276.105,220.954c12.347-21.527,19.459-46.545,19.459-73.18c0-81.455-66.327-147.717-147.846-147.717 S0,66.32,0,147.904s66.327,147.717,147.717,147.717c26.57,0,51.523-7.111,73.18-19.459 c39.822,53.333,91.863,113.519,126.061,116.364c12.283,0.517,22.885-6.723,32.776-16.743c5.172-5.624,13.77-16.937,12.8-28.768 C389.624,312.881,329.438,260.776,276.105,220.954z M147.717,273.77c-69.495,0-125.931-56.501-125.931-125.931 S78.287,21.908,147.717,21.908s125.931,56.501,125.931,125.931S217.212,273.77,147.717,273.77z M363.572,360.978 c-6.206,6.659-12.412,9.762-14.739,9.762h-0.065c-19.459-1.616-61.996-43.184-109.576-106.796c0-0.065,0-0.065,0-0.129 c9.18-7.24,17.455-15.515,24.63-24.63c0.065,0,0.065,0,0.129,0c63.612,47.58,105.18,90.182,106.796,109.576 C370.747,350.118,369.131,354.966,363.572,360.978z"></path></svg></div>
		<div id="filter" class="toolbarIcon" title="Filter by Regex [Shift + Ctrl + F]"><svg height="16px" width="16px" viewBox="0 0 392.541 392.541"><path style="fill:#FFFFFF;" d="M219.345,344.911V190.988c0-2.909,1.164-5.689,3.232-7.758L367.386,39.586 c3.814-3.814,3.426-7.434,2.392-9.891c-1.487-3.62-6.012-7.887-13.834-7.887H36.137c-7.822,0-12.347,4.267-13.834,7.887 c-1.034,2.392-1.422,6.077,2.392,9.891L169.503,183.23c2.069,2.004,3.232,4.848,3.232,7.758v174.093L219.345,344.911z"></path><path style="fill:#40b2ff;" d="M59.733,43.594L91.41,75.012c0.065,0,0.259,0,0.323,0h97.228c6.012,0,10.925,4.848,10.925,10.925 c0,6.012-4.848,10.925-10.925,10.925h-75.636l22.044,21.786h31.741c6.012,0,10.925,4.848,10.925,10.925 c0,6.012-4.848,10.925-10.925,10.925h-9.826l38.853,38.335l136.21-135.176L59.733,43.594L59.733,43.594z"></path><path style="fill:#004d80;" d="M356.008,0.022H36.137c-30.578,0-47.968,33.487-26.828,55.079l141.705,140.412v186.053 c0.065,7.111,7.564,13.382,15.192,10.02l68.396-29.543c4.008-1.681,6.594-5.624,6.594-10.02V195.513l141.64-140.412 C404.234,33.767,388.008,0.022,356.008,0.022z M367.45,39.586L222.642,183.23c-2.069,2.004-3.232,4.848-3.232,7.758v153.923 l-46.61,20.105V190.988c0-2.909-1.164-5.689-3.232-7.758L24.759,39.586c-8.339-8.792,1.099-18.295,11.442-17.778h319.806 C367.45,21.485,375.337,32.41,367.45,39.586z"></path></svg></div>
		<div id="flame-diff-reverse" class="toolbarIcon" title="Reverse Diff [Ctrl + R]"><svg height="16px" width="16px" viewBox="0 0 392.598 392.598"><path style="fill:#004d80;" d="M382.488,286.384c-3.62-3.62-9.438-4.267-13.77-1.422c-30.19,20.105-65.552,30.707-102.077,30.707 c-45.64,0-88.76-16.485-122.634-46.61l23.725-23.725c7.37-8.21,1.487-18.166-7.758-18.618H40.96 c-6.012,0-10.925,4.848-10.925,10.925v118.95c0.517,10.279,12.024,14.222,18.618,7.758l24.76-24.76 c37.947,34.263,86.626,53.01,138.085,53.01c55.143,0,125.285-23.014,172.154-92.444 C386.69,295.822,386.108,290.069,382.488,286.384z M211.692,370.747c-49.325,0-95.741-19.265-130.586-54.109 c-4.073-4.073-11.378-4.073-15.451,0L51.95,330.343v-81.842h81.778l-13.059,13.059c-4.202,4.59-4.461,10.99,0,15.451 c39.046,39.047,90.893,60.509,146.036,60.509c21.85,0,43.378-3.426,63.806-10.02C297.219,355.426,255.651,370.747,211.692,370.747z "></path><path style="fill:#004d80;" d="M248.605,123.475L224.88,147.2c-7.37,8.21-1.487,18.166,7.758,18.618h119.014 c6.012,0,10.925-4.848,10.925-10.925V35.943c-0.517-10.279-12.024-14.222-18.618-7.758l-24.76,24.76 C281.122,18.683,232.508,0,180.985,0C125.841,0,55.829,23.014,8.831,92.444c-2.909,4.331-2.327,10.02,1.422,13.77 c3.62,3.62,9.438,4.267,13.77,1.422C54.213,87.531,89.575,76.929,126.1,76.929C171.611,76.865,214.795,93.349,248.605,123.475z M180.92,21.786c49.325,0,95.741,19.265,130.586,54.109c4.073,4.073,11.378,4.073,15.451,0l13.705-13.705v81.778h-81.778 l13.059-13.059c4.202-4.59,4.461-10.99,0-15.451c-39.046-39.046-90.893-60.509-146.036-60.509c-21.851,0-43.378,3.426-63.806,10.02 C95.393,37.107,136.96,21.786,180.92,21.786z"></path><path style="fill:#ff8d40;" d="M340.661,62.255L326.956,75.96c-4.073,4.073-11.378,4.073-15.451,0 c-34.844-34.844-81.261-54.109-130.586-54.109c-43.96,0-85.592,15.192-118.82,43.248c20.428-6.659,41.891-10.02,63.806-10.02 c55.143,0,107.055,21.463,146.036,60.509c4.461,4.396,4.202,10.796,0,15.451l-13.059,12.994h81.778L340.661,62.255L340.661,62.255z"></path><path style="fill:#40b2ff;" d="M81.041,316.638c34.844,34.844,81.261,54.109,130.586,54.109c43.96,0,85.592-15.192,118.82-43.249 c-20.428,6.659-41.891,10.02-63.806,10.02c-55.143,0-107.055-21.463-146.036-60.509c-4.461-4.396-4.202-10.796,0-15.451 l13.059-13.059H51.95v81.778l13.705-13.705C69.728,312.566,76.968,312.566,81.041,316.638z"></path></svg></div>

		<div id="flame-mode-flame" class="toolbarIcon toolbarSelected" style="margin-top: 16px" title="FlameGraph [Ctrl + 1]">
			<svg height="20px" width="20px" viewBox="0 0 20 20"><rect x="0" y="0" style="fill:#ff8d40;" width="20" height="4"></rect><rect x="0" y="5" style="fill:#40b2ff;" width="10" height="4"></rect><rect x="11" y="5" style="fill:#ff8d40;" width="8" height="4"></rect><rect x="0" y="10" style="fill:#40b2ff;" width="8" height="4"></rect><rect x="11" y="10" style="fill:#ff8d40;" width="4" height="4"></rect><rect x="0" y="15" style="fill:#40b2ff;" width="4" height="4"></rect><rect x="5" y="15" style="fill:#ff8d40;" width="2" height="4"></rect></svg>
		</div>
		<div id="flame-mode-reversed" class="toolbarIcon" title="Reversed FlameGraph [Ctrl + 2]">
			<svg height="20px" width="20px" viewBox="0 0 20 20"><rect x="0" y="0" style="fill:#ff8d40;" width="6" height="4"></rect><rect x="7" y="0" style="fill:#ff8d40;" width="5" height="4"></rect><rect x="13" y="0" style="fill:#ff8d40;" width="4" height="4"></rect><rect x="18" y="0" style="fill:#ff8d40;" width="2" height="4"></rect><rect x="0" y="5" style="fill:#ff8d40;" width="6" height="4"></rect><rect x="7" y="5" style="fill:#40b2ff;" width="5" height="4"></rect><rect x="13" y="5" style="fill:#ff8d40;" width="4" height="4"></rect><rect x="18" y="5" style="fill:#40b2ff;" width="2" height="4"></rect><rect x="0" y="10" style="fill:#ff8d40;" width="4" height="4"></rect><rect x="7" y="10" style="fill:#40b2ff;" width="2" height="4"></rect><rect x="13" y="10" style="fill:#40b2ff;" width="4" height="4"></rect><rect x="13" y="15" style="fill:#ff8d40;" width="2" height="4"></rect></svg>
		</div>
		<div id="flame-mode-methods" class="toolbarIcon" title="Methods List [Ctrl + 3]">
			<svg height="20px" width="20px" viewBox="0 0 20 20"><rect x="0" y="0" style="fill:#ff8d40;" width="20" height="4"></rect><rect x="0" y="5" style="fill:#40b2ff;" width="16" height="4"></rect><rect x="0" y="10" style="fill:#ff8d40;" width="8" height="4"></rect><rect x="0" y="15" style="fill:#40b2ff;" width="4" height="4"></rect></svg>
		</div>

		<div id="info-tooltip">
			<div style="float:left">
				<div style="padding: 4px;">Frame types:</div>
				<div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
				<div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
				<div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
				<div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
				<div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
				<div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
				<div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
			</div>
			<div style="float:left; margin-left: 4px">
				<div style="padding: 4px;">Special colors:</div>
				<div class="colortip" style="--c1:#40b2ff;--c2:#40b2ff">Matches regexp</div>
				<div class="colortip" style="--c1:#ffdd33;--c2:#ffdd33">New frames</div>
				<div class="colortip" style="--c1:#66e0f0;--c2:#66e0f0">Same frames</div>
				<div class="colortip" style="--c1:#42ff8e;--c2:#ccffe0">Less frames</div>
				<div class="colortip" style="--c1:#ff8d40;--c2:#ffe0cc">More frames</div>
			</div>
			<div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
				Shift + Click - Select range<br>
				Ctrl + Click - Compare<br>
				<br>
				Ctrl + F - Search<br>
				Shift + Ctrl + F - Filter<br>
				Ctrl + R - Switch Diff<br>
				<br>
				Ctrl + 1 - Select FlameGraph mode<br>
				Ctrl + 2 - Select Reversed FlameGraph mode<br>
				Ctrl + 3 - Select Methods List mode<br>
			</div>
		</div>
	</div>
</div>
<div style="display:none">
	<pre id="executionsHeatmap">SNj
wy]IH`
	y*ElRSM+m0y%h@hUE}tU{!P;$	u7/.FC?
025c7w*@-!q(	
|THmZ
XCL+67k!y/:!P$	t7wTAS!6x/V%OB+'"RH-wR$5HQN"N4 =~+1w-~mU:JUVN#jV:%$_@EOO6=!!7@QPopeZqek	$$x@,NS}bBp4$E1 hJx?0ZFQdb 6\6Tz.$E=$uFLXEEkS
/[%\sT|OOY'"Zq6//,|$m+'-{/Rm@=l=HCWz6VyEl O*/$_;~B*;$aES$jCM5J/Ot-	ZV	-+@4M\XW;QM6=	D!@$_;$JQFl++-4p  "TR]g\:JS7n5$	uNE/B,X;
Y(~)4-L |?c,3BN@y=E'^PPD{ =1N=
]x1VPJ%[UKKr:r:{=NAuAoQhZ[;UGiMvOB__;=|F=Z=TGLJYQPSYSVZL[d[R]_]F^Y_Wbq;t;E|c|q|s|W=_=h{i{s{v{q?]A\B{DZDwDoEJFKFrH@LJLCM_MbMKNsNVOOPbQkR\S]TbUXVgXsXJ[f\_aiaieOfY;Z;];v;{|@|J|W|_|`|e|g|u|v|y|X=]=d=j=l=s=t=?{P{Z{f{m{p{x{R?l??@K@L@u@v@JAYAABIBPBSBUBZB]BiBFCLCRC[CyCFDNDeDiDsDtD=EDETEVEYE=F?FDFLF_FcFiFlFnFpFqFMGSGvGAHMHPH`HeHfHgHJIRIkIFJMJOJQJdJfJjJ{KQKsK=L{LQLjLpLRM`MuMxM=N{NANHNLN_NoNFOIO_OfOSP[P]P_P`PsPuPOQ^QaQcQtQDRIRORPRVRXR_R`RvRxRRSvSGTJT`TdThTqTBU[U`UfU?VUVWW]WkWsWDXEXWXXX^XCYTYWYXY]YyYAZ^ZcZpZsZ?[V[Y[?\B\R\m\o\q\u\=]S]`]=^{^o^p^t^u^x^i_@`K`[`q`r`=ahajakaYb]b]cFdKdOdfdPeUepevemfNg[gahIi^i`iniGjejujblvlDmBpwpJrs:u:v:w:H;J;K;L;M;N;O;P;Q;R;S;T;U;V;W;X;\;^;`;a;b;c;d;e;f;g;h;i;j;k;l;m;n;o;p;r;s;u;w;x;y;?|A|B|C|D|F|G|H|I|K|L|M|N|O|P|Q|R|S|T|U|V|X|Y|Z|[|\|]|^|a|b|d|f|h|i|j|k|l|m|n|o|p|r|t|x|?=@=A=B=C=D=E=G=H=I=J=K=L=M=N=O=P=Q=R=S=T=U=V=Y=[=\=^=`=a=b=c=e=f=g=h=i=k=m=n=o=p=q=r=u=v=w=x=y=={@{A{B{C{D{E{F{G{H{I{J{K{L{M{N{O{Q{R{S{T{U{V{W{X{Y{[{\{]{^{_{`{a{b{c{d{e{g{j{k{l{n{o{q{r{t{u{=?{???N?O?P?T?U?V?W?X?Y?Z?[?\?]?^?_?`?a?d?g?r?s?t?u?v?w?x?y?=@{@@@A@B@C@D@E@F@G@H@I@J@M@N@O@P@Q@R@S@T@U@V@W@X@Y@Z@[@\@]@^@_@`@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@w@x@y@=A{A@AAABACADAEAFAGAHAKALAPAQARASATAUAVAWAXAZA[A\A^A_A`AaAbAcAdAeAfAgAiAjAkAlAmAnAoApAqArAsAtAwAxAyA=B{B?B@BBBCBDBEBFBGBHBJBKBLBMBNBOBQBTBVBWBXBYB[B_B`BaBcBdBeBfBgBhBpBrBsBtBuBvBwBxByB=C{C?CACECGCHCICJCKCMCNCOCPCQCSCTCUCVCWCXCYCZC\C]C^C`CbCeChCjCkClCmCnCoCpCqCrCwCxC=D@DADGDHDIDJDKDLDMDODPDQDRDSDTDUDVDWDXDYD[D\D]D^D_D`DbDcDdDfDgDhDjDkDlDmDnDoDpDqDrDuDxDyD{E?E@EAEBECEEEFEGEHEIEJEKELEMENEOEPEQERESEUEWEXEZE]E^E_E`EaEbEcEdEeEfEgEhEiEjEkElEmEnEqErEsEuEvEwExEyE{F@FAFBFCFEFFFGFHFIFNFPFQFRFSFTFUFWFXFYFZF[F\F]F^F`FaFbFdFeFfFgFhFjFkFmFoFsFuFGGIGJGKGOGPGQGRGWGXGYGZG[G\G`GaGbGcGdGfGgGhGjGlGmGoGpGrGsGtGuGxG?H@HBHCHDHEHFHGHHHIHJHKHLHNHOHQHRHTHVHWHZH]H^H_HaHbHcHdHhHiHmHoHqHsHtHuHvHwHxHyH=I?I@IAILIMINIPISITIUIVIWIXIYIZI[I\I]I^I_I`IaIbIdIeIgIiIjIlInIpItIvIwIxIyI=J{J?J@JAJBJDJEJGJHJIJJJKJRJSJUJWJXJYJZJ[J\J]J^J_J`JbJcJeJgJhJiJkJmJsJtJuJvJwJxJyJ=K?K@KAKBKCKDKEKFKGKJKLKMKNKOKRKSKUKWKXKYKZK[K\K]K^K_K`KaKbKdKeKfKgKhKiKkKmKnKoKpKqKrKtKuKvKwKxKyKBLCLDLFLGLHLILKLPLSLTLULVLWLXLYL[LbLdLiLlLnLrLsLtLuLvLwLxLyL=M{M?M@MAMBMDMEMFMGMHMIMJMKMLMMMNMOMPMQMSMTMVMXMYMZM[M]MaMcMhMjMkMlMmMnMoMpMqMrMsMtMvMwMyM?N@NCNDNENFNGNINJNPNRNSNTNUNVNWNXNYNZN[N`NaNbNcNdNfNhNiNjNkNlNmNnNtNvNwNxNyN=O{O?O@OAOBOCODOEOGOHOJOLONOQOTOUOWOXOZO[O\O]O^O`OaObOcOdOeOjOkOlOmOnOoOpOqOrOsOtOuOxOyO=P{P?P@PAPDPEPGPHPIPJPKPMPNPPPTPUPVPWPXPYPZP\P^PaPbPcPdPePfPgPhPiPjPkPlPmPnPoPpPqPrPtPwPxPyP=Q{Q?QCQEQFQGQHQIQPQQQRQSQTQUQVQWQXQ`QdQeQfQgQhQiQjQkQlQmQnQrQsQARCRJRKRLRMRNRQRSRTRURWRYRZR[R\R]R^RaRcRdRgRhRlRnRoRrRsRtRuRyR=S{S?S@SASCSDSFSGSJSMSQSTSVSZS[S]S_S`SaSdSeSfShSiSjSlSmSnSoSpSqSsStSwS=T?T@TDTFTHTITKTNTOTPTQTRTTTUTYTZT[T\T^T_TaTbTcTeTfTgTiTjTkTmTvTwTyT=U{U?U@UAUCUDUEUFUGUHUIUJULUPURUXUYUZU\U]U^U_UeUhUlUnUoUqUtUuUxUyU{VCVFVJVNVQVRVTVVVYVZV\V]V^V_V`VaVcVeVhVlVoVpVrVwVxVyV=W{W?W@WBWCWEWGWHWIWJWKWLWMWNWOWPWQW[W\W_W`WcWeWfWgWiWjWlWmWoWtWuWxWyW=X{X?X@XAXBXCXFXGXHXIXJXNXOXPXQXSXTXUXVX[X`XaXcXeXhXiXjXkXlXmXnXuX?YFYGYIYKYVYYY^Y_Y`YaYcYdYeYgYiYmYoYpYqYtYuYvYwYxYCZEZMZOZPZQZRZSZZZ\Z`ZjZlZxZyZ@[B[D[F[G[H[I[N[O[P[R[U[W[][j[l[v[w[x[y[=\@\A\D\G\J\L\T\X\Y\_\n\p\r\s\t\w\?]A]C]E]P]W]X]Y]Z]\]b]c]e]f]g]h]i]n]r]t]v]y]@^A^B^D^K^L^O^P^Q^R^S^T^W^X^Y^Z^[^a^c^d^e^f^g^h^i^m^n^q^r^s^v^w^{_?_@_E_K_L_M_N_O_P_Q_R_S_T_V_W_e_f_j_k_l_q_r_s_t_u_v_w_x_B`C`E`I`J`M`O`Q`R`S`T`U`f`h`i`l`w`@aAaCaEaFaHaJaNaOaPa[a]a^a`aaaeafalamaqavayaGbHbVbZb[b\bebgbibjbqb=c@cBcJcKcMcOcUcWcXc\c^caclcocqcrc?dHdIdQdRdUdWdXdYdZd]d^d_dcdedhdkdldmdndodqdxdyd{e?e@eSeWeYe[eaejekelemeneoe=f{f?f@fAfWfYfZf^fbfcfdfnfufwf=g?g@gBgDgFgIgWg\g^gcgkgrgChZh_h`hbhchehjhlhshxh=i{i?iBiOiQiVi_ilimipiriPjajfjhjyj=k?k@kCkOkPkQkRkSkUk`klkvk=lDlNlRlelllyl{m@mCmImNmUmdmkmlmmmompmrmumAnFn[nennnCoEoLoQoaomowoYpZp[p`pppqptpypGqSqiqGr@sDsRs_sqsrsQtOut:x:y:=;{;?;@;A;B;C;D;E;F;G;I;w|=={{w{y{@?A?B?C?D?E?F?G?H?I?J?K?L?M?Q?S?b?c?e?f?h?i?j?k?m?n?o?p??AIAMAOAhAvARB^BbBjBkBlBmBnBoBqB@CBCCCDC_CaCcCdCfCgCiCsCtCuCvC?DBDCDDDEDaDvD[E\EpEtEMFOFVFrFtFvFwFxFyF=G{G?G@GAGBGCGDGEGFGHGLGNGVG]G^G_GeGiGkGnGqGwGyG=H{HSHUHXHYH[H\HjHkHlHnHpH{IBICIDIEIFIGIHIIIKIOIQIcIfIhImIoIqIrIsIuICJNJPJTJVJaJlJnJoJpJqJrJHKIKKKPKTKVKcKjKlK?LALELLLMLNLOLRLZL\L]L^L_L`LaLcLeLfLgLhLkLmLoLqLUMWM\M^MdMeMfMgMBNMNNNONQN\N]N^NeNgNpNqNrNuNKOMOOOPOROSOYOgOhOiOwOBPCPFPLPQPRPvP@QAQBQDQJQKQLQMQNQZQ[Q\Q]Q_QpQqQuQvQwQxQyQ=R{R?R@RBRERFRGRHRRRbReRfRiRjRmRpRqRwRBSESHSISKSLSNSOSSSUSWSXS^SbScSgSkSrSuSxSyS{TATBTCTETLTMTSTVTWTXTlTnToTpTrTsTtTuTxTKUMUNUOUQUSUTUUUVUWUaUcUdUgUiUjUkUmUpUrUsUvUwU=V@VAVBVDVEVGVHVIVKVLVMVOVPVSVWV[VbVdVfVgViVjVkVmVnVqVsVtVuVvVAWDWFWRWSWTWUWVWXWYWZW^WaWbWdWhWnWpWqWrWvWwWKXLXMXRXYXZX\X]X_XbXdXfXoXpXqXrXtXvXwXxXyX=Y{Y@YAYBYDYEYHYJYLYMYNYOYPYQYRYSYUYZY[Y\YbYfYhYjYkYlYnYrYsY=Z{Z?Z@ZBZDZFZGZHZIZJZKZLZNZTZUZWZXZYZ[Z]Z_ZaZbZdZeZfZgZiZkZmZnZoZqZrZtZuZvZwZ=[{[A[C[E[K[M[Q[S[T[X[Z[[[\[^[_[`[a[b[c[e[f[g[h[i[k[m[n[o[p[q[r[s[t[u[{\C\E\F\H\I\K\M\N\O\P\Q\S\U\V\W\Z\[\\\]\^\`\a\b\c\d\e\g\h\i\j\k\l\v\x\y\{]@]B]D]F]G]H]I]J]K]L]M]N]O]Q]T]U]V][]]]^]a]d]j]k]l]m]o]p]q]s]u]w]x]?^C^E^G^H^I^J^M^N^U^V^\^]^^^_^`^b^j^k^l^y^=_A_C_D_F_G_H_I_J_U_X_Z_[_\_]_^___`_a_b_c_d_g_h_m_n_o_p_y_=`{`?`A`D`F`G`H`L`N`P`V`W`X`Y`Z`\`]`^`_```a`b`c`d`e`g`j`k`m`n`o`p`s`t`u`v`x`y`{a?aBaDaGaIaKaLaMaQaRaSaTaUaVaWaXaYaZa\abacadaganaoaparasatauawaxa=b{b?b@bAbBbCbDbEbFbIbJbKbLbMbNbObPbQbRbSbTbUbXb^b_b`babbbcbdbfbhbkblbmbnbobpbrbsbtbubvbwbxbyb{c?cAcCcDcEcFcGcHcIcLcNcPcQcRcScTcVcYcZc[c_c`cbcccdcecfcgchcicjckcmcncpcsctcucvcwcxcyc=d{d@dAdBdCdDdEdGdJdLdMdNdPdSdTdVd[d\d`dadbdddgdidjdpdrdsdtdudvdwd=eAeBeCeDeEeFeGeHeIeJeKeLeMeNeOeQeReTeVeXeZe\e]e^e_e`ebecedeeefegeheqereseteuewexeyeBfCfDfEfFfGfHfIfJfKfLfMfNfPfQfRfSfTfUfVfXf[f\f]f_f`fafefffgfhfifjfkflfofpfqfrfsftfvfxfyf{gAgCgEgGgHgJgKgLgMgOgPgQgRgSgTgUgVgXgYgZg]g_g`gagbgdgegfggghgigjglgmgngogpgqgsgtgugvgwgxgyg=h{h?h@hAhBhDhEhFhGhHhIhJhKhLhMhNhOhPhQhRhShThUhVhWhXhYh[h\h]h^hdhfhghhhihkhmhnhohphqhrhthuhvhwhyh@iAiCiDiEiFiGiHiJiKiLiMiNiPiRiSiTiUiWiXiYiZi[i\i]iaibicidieifigihiiijikioiqisitiuiviwixiyi=j{j?j@jAjBjCjDjEjFjHjIjJjKjLjMjNjOjQjRjSjTjUjVjWjXjYjZj[j\j]j^j_j`jbjcjdjgjijjjkjljmjnjojpjqjrjsjtjvjwjxj{kAkBkDkEkFkGkHkIkJkKkLkMkNkTkVkWkXkYkZk[k\k]k^k_kakbkckdkekfkgkhkikjkkkmknkokpkqkrksktkukwkxkyk{l?l@lAlBlClElFlGlHlIlJlKlLlMlOlPlQlSlTlUlVlWlXlYlZl[l\l]l^l_l`lalcldlflglhliljlklmlnlolplqlrlsltlulwlxl=m?mAmBmEmFmGmHmJmKmLmMmOmPmQmRmSmTmVmWmXmYmZm[m\m]m^m_m`mambmcmemfmgmhmimjmnmqmsmtmvmwmxmym=n{n?n@nBnCnDnEnGnHnInJnKnLnMnNnOnPnQnRnSnTnUnVnWnXnYnZn\n]n^n_n`nanbncndnfngnhninjnknlnmnonpnqnrnsntnunvnwnxnyn=o{o?o@oAoBoDoFoGoHoIoJoKoMoNoOoPoRoSoToUoVoWoXoYoZo[o\o]o^o_o`obocodoeofogohoiojokolonooopoqorosotouovoxoyo=p{p?p@pApCpDpEpFpGpHpIpJpKpLpMpNpOpPpQpRpSpTpUpVpWpXp\p]p^p_papbpcpdpepfpgphpipjpkplpmpnpoprpspupvpxp=q{q?q@qAqBqCqDqEqFqHqIqJqKqLqMqNqOqPqQqRqTqUqVqWqXqYqZq[q\q]q^q_q`qaqbqcqdqeqfqgqhqjqkqlqmqnqoqpqqqrqsqtquqvqwqxqyq=r{r?r@rArBrCrDrErFrHrIrKrLrMrNrOrPrQrRrSrTrUrVrWrXrYrZr[r\r]r^r_r`rarbrcrdrerfrgrhrirjrkrlrmrnrorprqrrrsrtrurvrwrxryr=s{s?sAsBsCsEsFsGsHsIsJsKsLsMsNsOsPsQsSsTsUsVsWsXsYsZs[s\s]s^s`sasbscsdsesfsgshsisjskslsmsnsospssstsusvswsxsys=t{t?t@tAtBtCtDtEtFtGtHtItJtKtLtMtNtOtPtRtStTtUtVtWtXtYtZt[t\t]t^t_t`tatbtctdtetftgthtitjtktltmtntotptqtrtstttutvtwtxtyt=u{u?u@uAuBuCuDuEuFuGuHuIuJuKuLuMuNuPuQuRuSuTuUuVuWuXuYuZu[u\u]u^u_u`uaubucudueufuguhuiuyYZnM	efghijklmnopqj
fg^_`FGHIWXJYZwxyIbKc{KLIdMNOP?5@QRABSCD	6E7~cFL*
ikb#$o
OMN%+,-8./} 09:TUV^?eWX@ABfYZgCOPDEq?fB`DGFIHXJYLwNJO~bcRJLTMVOX?Z@\R^B`ClDL6f7~hqj*vns#upYx%{P+A-C.E}QR`DEh[\]^jSmaVWkgCFEHGWIJKZMxyb`~{SdUNWPY5[Q]A_Sa#DlEgZjFntq#s
w~X=?@,B8D/FR H9ITJVK?MWO@qIKlw|qLW;_^WFLIZJOwhXYZ[\]^_`aH?@X?L@e_KGYWNY\xQ_~caLcNX?fQ`[jfHIkCDZJ	EFGf`XHUVWgFCZP~yRGTbVMdPY@gA[CD^7"Na#Fc
Oae$p_vjx,m.[ldmn2JK((G[ZSyUcHLJOe5ZRhS\D^`rcYet$iZik+y8n}QmFnnps=e^={nsabcdieDgX~b
d
f
vHMXww]yF{	WIYNK5B	A\]	eE_~`Jl=OPrstQnoPpQwRSTxU{VI=YDTe	Qg	L@	P[Q`Bil	6mG	b	oaK	r$M	~h%wl-=/bG0MqMyNOrsNtaMWAV	=]	iWRwc	^efgFhabcdefd
Xb	xEPV{UdWOA	@hBN
E		m	7"`o	lNOPetu@mn_k
Jl
bSo
Xdq
PM
RC	C]	v
t	sT	'q3rKt"rsWyxYG
d	g
f]	=={QZxf
Bn
{p
MZ?LRGO
E){`abwu=m?_`_JKLyg	klZTw=	J
Dh	d[Ak	u
6P
~p	=LJU	4b
{pf\1oPsW{Bnopq?xAbCXEMZ5nBt
k	I~XpFI	dL	aN	%X
+Q	.k[
9%UTEtKi}qx;=m
f	eLL
?gBBd	B`H	FFp#fu~W
hY
8kldoumnn[p!qoQRVS?fMA@s
SD	C6@YR
*i]$V
y%K,j/q $gGGa	Mt	NhYNj	@H6pGsZU
I~`P	,x}l =~GhijHXOwA~ycc?	i	Or
QoSnW6E~E	S

dK#^jO	i-Z
}K~0:SUT^LeNXPARf Z!prsktusIdiOL'P~I
cQ~dyi	BCDEFGHIJKLMNk~RdjLU5n[NfQuCcDAtXm~eh
gj
htuvEwFGb@NC~QD~EK2e)Hofeo\rH{W{B~OS~RbcdetxnopKLuvwFGPFAhoE)qb	X~J	Z~$ugJ~-{R?DAhD]FmPn~{Q?FvAwD~E~`cl~MAno@ABdCefogo\]\]KdK
R~PXBVDF	~DKF\YH~va+L/bSYXYt[\]^_`abnTo?FSU~D1{cl_ASA	XJF#[~Jw,L_Y`@EBiC\[\`{a5CCA7"fF~gG~LnNpvhH~ijI~J~K~R?OHARV~ETF	WJ#H~I~^~8k_LD^iO]T[\]={[\Mm+K=?ed[kN@R\iE_W~*F~G$Z]~b.[_fEN[Z^ESGTHUIbJcCpE!IHoLp~@h[USTHDjtT
t
gv\8cdFS	M=EdSjOl(h[PMlQMrsv	w	x	y	O=
kBQPtPUNUatu[e.C L~hN~jq~Cs~DVTeC1jfg1?^O\Bp	EG
Y~vbx+x}_~9g.hgHmGxbctoPX[UKhijpkL={UFGHIl\2?@CTQ
V*u##cKP{
ROPQRSTv~Uc~?klmeLSym{n!IQ_Rn5Qr7Fr	`I_Oy/y0`~Tp^b~WcAe~YTgUOVZ]{np@JLft%w-No0_Un	hct~AhQovbwaBCDfEgFj]qr^hKLMNlcsRS7WrHs
Jc]}l_B3O4AJtJ(sB@`H!u1nLgs[@hB?@_A?@B`UaABN@tSD6MJRPKQIJS"RHxy=	KLMWCkK=c[KvofHd@i[	YD[F+vo9MMNwg^7AKCM$w%m8i $:a~Vqec~@QBSY4pg~sQv-iTA,?GHXYZ`[oDb=F	96HEsX*jH
Eu,L{:x^aXd~B?Z!CUPLMNI7rk
M%u.NUVlN-nR	m[~qB
rslJ-_ $MR
ct	_i*KG~
Xe8v0gxiO~H=G?bmik#Nm,AD:rXRff~gp@k-lv|wLCXk\~%Y/G4{\l]%B}kgpj/I0NMPr_
spHDa?c
mL.e0pVE-FGIq
bWGn.U9\]^QURWXA[/MmJE#s^8e=eu~Fvt~u~Qw~x~y~=HHwjAiQ_7bqrtuJwy=E
V;fKMjCkE=3M]^_`qefghKM?gAT@STUVh[	a]F^T/yWj~KN|jvF=}k:TB	`?	yd/=AcZNj	}k	fT*r$t_}ATbY
qDVk8`
P\	Ib$J@SyY{Zwo	p	tg_`jJklmnoaBJpne@gBhCQRtvtaa\XYmu`	c
thP@RAOBVUyF	M[lC(=L"N
w#c%H{MrMsN^
r`
NfQYCGiq\
y]
OONa
aulb$OD}HG`ne4=RlXNOPYZ[ua
SwOT`?w@{fDpEv@|?n+nE@IPDMFGHI[Z'd"KLoOP+G wTBeEByrh~kS|GQxR,u fi:ILOacdeUVfW`Y#K`n^$]_eOaPcraJ jsuo=og	DfmoqIJe
@bGZ^_`abl=hP\Yib?bjskumwqk\ofA[diekoG
huvw?@]duf\gFIJK|abId@q	WoWvQRAB5r	Cs	DnF,KQ\X=tZRp	Tm{`Y~Z~dsDZ-f0oGM~i:CMAH~`8xKS0yINrktMt-I9wGJjKXV
DCs	EFRd.\:SM
YJwA[={?@V%vTTWbBWGj	Z_[UO?\AFgBN	HIJSKLTjB\`f0V?@ABYB^edg^ZGt{bgh	w[VxN~nM ^UbeUf NODPQARBCDEs@kj+N9%j@,oiA-]fdHfJhKjTlQoQklC8K.L/L?cJeKxMoWKOD	mY	Z@
A
TLkk]rH
CjDEM}IGTHqxlVJ'{_
NsPyouWDYEIgSiLmBHl~m~n~o~SOGPQRSTUR?uvwAaVQXxY?r_v=w}jp tVL	VWXYrZ[h0fG{~MYYGijkpcZ2ASB[ZTw_~xy=`~{QRSTo_m\]Ti\k=V~W~tQMh^vQEHsZ	bKLMt]fi
FvqB
rDEFG?={?CGDiUXC
VWopq9%bK	@gJHYbmVOvp_l?@:WYXYZxT\XeZ!B^JGLm]O	M
XN
`HGXI0V
URSJG=hOX?5q=^AU\XKgVsQtRqg|X;PVQlxTb	c	d	e	{MlN'{R[W=GiYss_6YZ[nQ_jklmngdxo]oAB+H	TI	UVWPjklmnopjpYd`FN2CETqE;xYGC^Q@CYfsAIdlFqAamGMTUVWsqhwrVtST0UVk3kJBTfkIJuQ	2i	Z
.LMmnoCstjdefghm	D
gmB?DqFeEmqW]ZTOVL~M~BKqur~crdZ=W	XX	YZ[\]^_`abc_[+Qhn?a	?~y[gNlKy==4Ni:m{x?VwP?j/m@bnx	P=
Q?
RA
TC
UCL	abcd]~v^eU`	VWXYZ{(L"Br?
@xOpXQeSSA
UgJHIcVwqrGXI`aP
xR]E{\u[j]l{c\d[Zq~r~s~KDZ[\]`w
kl?	@	A	B	C	aKQE	LIbjF{M\]lNMMn]Q@fZPr_tSIWqEEMrOPcISbdd~e~f~g~lh7ijkltvnxoKp{F
kl{?)uneHiWklmn	mnopqf'
R
S
'ERXPPsmWX={X[jklOWlQfj_T\?\]^b?u?xBca@h~i~j~k~j@2JRBk`SamSTCQhoLQAcp^NH|k	Vl	O^_`abcdefggpDLP\ilOopQ3=RLMNXBqgrUitkvE
wIcxy=Yu@~EKT`yibTv]X[eOW
PX
Qhij
qrta_\_RSTUVWgJKLXYvwxZyE[E\]hhx
ty
@WKRM	BHV[Vi@ABCIDE,AumvoxqFgWhsjulmnDfgsopqAE\JJH	]I	^rstuvwb3=xyhjbLutDi{uKx=_AcauCwB=NOPQp~?[Yks{N\[N_`a2BCDHvE
YZ[\]^OP		{BdT
xU
y={?@ABCR?{r6GYLqVf wxy={ZVoVpUDC
FWZO
=u\Ay4K	@g
^k_x
y
bIPlULMNOPQIKu	LS@q@U`7aF	ijklmnFASCM(|cdefghS"]lyN=PPXQ
FGjJ
K
L
MNL?
MnavBRSPTVT5O	_AS
Dv	Wx	YNMatpP]HY?W_|deaEy	p@
S{LZ]jNPqyYN
defg=@=ki
d^	eQcLMNOPQRghiEjHIJKb	Vd	Xf	opIMrYjYHAbZrS`_[n[W=afghvixEylZNOPQpgfmP_hpirlv=Vk_	^_py`aeMrcxy^D{!ZiEV;xrstuvwxyMiIc={m)GpEtR?@AYrIy^BR~klmRSTbNwDihi?a^	eaJ
VL
_j{
PSTUVWGmTW	vX	wSTU8Li{?]h=3UDD
RR	USS	TT	KUU	VV	WHWbj?hk
l
]w_`abcdOU	PV	yE|uvwCjfyF=UMS	NT	K={vgv~tx~v=wSTUUJGXq	ApOR[j@
TTF
sZ	\kuvwxy={_R^x`=	{	nm{hUVaklmnhh	qU\CDEFGHIIFGHIJKAkBmS~CLMqD=CeOlwfTF{HrmuO~P~Q~^sRuRlFjTUVWXsRFcHIJdYs@GCsn@`Aa~b~ZEtCDEFGd?DWwxy=g
IVJX?Wwxy=gV[G	NOPQRS_k`wB;gh
jPCw]xUVWUP`YZfpVZpLcO]tAOHuqstwIciQ	
y={rwjZkZxyXyDZE[F\NhaSTHIv]	S{?@lv@]\yWLs`aboa`]^_J\]^TWXRNMrfa`HnPIMh]J{Ne9@ABCDEFGHIJpOBuLVJVxNvZS\F
WZ	^HNOLPfop9nopqrsta
a	e
RhLakIRiUF@B
Astu(={?@ABw?\]^_`abcdefiedG
vijklEb\	dFX?BcKLMBf\MmnopqDOxPyrstuvwxyCdcdefhmZ
.G[Ys@V,I
rnwpyHbcdmu_neDo]FTVJKLMNOg[qSorstuviIJKrg^\m^HIJKGixekopDE\U[
F\
G]
H^
L[KSgefgY
HHIXYQJ	[`b[~\~A^^~	fUgVxthYiu`aQ]hijq\j{Gm	ng?MJ=i{UMELA!GBLS`TpqltnKuwmEdI`	JqKrLCiAiG	xyE`FFQNy={?GK
WQR={?@ABCXuj|UPuTTXEZ^T~U~YlTO{P`Q
stN\V\w\dNsnYQeVWXoIWft	imnsol]^JXKY@wLcc	We	f	nAXrD[EhiRSSmH;bNl`@	bB	doPLD	RY	nopqrvCYBo\RExK_ya{	XnR[UPQR_w	Xy	Z=
{H
YlCbcpK{qtdEDiQ=R{JKtivklm?M`R?@x^a_y`Hn	\]hwoxq=r{HIJKdem
n
o
p
q
r
s
t
u
ucc
ev
u^pE{UrMHIJVN	eI_KHk[QmpqmMrstuvCopb\SVI\]evqauCi][Df!tJV]W^X_Y`ZaeFGHuT`=[NOPQRSTUVWkC^[_FGfgkXnopqrstuv@hw~uy~RqSkrs?qloIgwmEhmnopqrstuvxJKR	LVHbcdshijkVJQ]rUD\d@QUyCDEFGHwBN@OXYZ[\qI]^_Pcdefghi]KcL'dfyqrQah;Ou^ktuv]^vTm{c{ebW
cX
dRuvwxv^
defEknqOGGp@y=~{~?~@~A~B~C~HInD[YQto	S^sgXhZOu	OPu;WqPCNsMtuj?@ABCbYopUur]rr6s@^`awHxyuUrpvs]JvKxkZRYuvwxy={?@ABCDEVWXYpZd_ndvGBhHFSWknr	CDaGoBvDxEyFF^{ijAcg|GBT_QRSqrstFT
CU
DYZ[`?	aA	cC	eLaE	^_Wc({?@ASopqrstuvwxyFFGHplO=3abcWXYs[=1ghijklU1ABCxNMUDqjjbwgor:eNONX_Nf@ZiGw{rFVKWuXujRL`fuguK?_uwREDlHZ_ZnsstsusvswsxsysOtPt{{MA{ElJtWYZgZ[cUfAk{p?p@pwpxpypiqjqhuiu==KOaUbWJYU_U`V`W`X`Y`Z`dd=eahbhchdhfjgjhjijrksktkAmBm`papbpcpdpgrhrirjrXsYs_s`sasZtQ?IAKC_CMFUJVJWJXJYJZJ[J\J]J^J_J`JaJbJcJdJeJfJgJhJiJ=LrNSOaQhRBSVWuWvWwWbXcXdXeXfXB\C\D\E\F\G\H\I\O\t\=]{]?]@]H^L^M^N^r`s`t`u`v`w`x`y`yb]c=d{dZeTfVfaioiBjCjDjEjFjRjajbjcjdjEkSkTkXlYlZl[laljlDmEmFmGmHmVnWnXnnnon=q{q?q@qAqBqkqlqmqkrlrjss:t:u:v:w:x:y:=;{;?;@;A;B;C;D;E;F;G;H;I;J;K;L;M;N;O;P;Q;R;S;T;U;V;W;X;Y;Z;[;\;];^;_;`;a;b;c;d;e;f;g;h;i;j;k;l;m;n;o;p;q;r;s;t;u;v;w;x;y;=|{|?|@|A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|[|\|]|^|_|`|a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|x{y{=?{???@?A?B?C?D?E?F?G?H?I?J?L?M?N?O?P?R?S?T?U?V?W?X?Y?Z?[?\?]?^?_?`?a?b?c?d?e?f?g?h?i?j?k?l?m?n?o?p?{A?A@AAABACADAEAFAGAHANAOAPAQARASATAUAVAWAXAYAZA[A\A]A^A_A`AaAbAcAdAeAfAgAhAiAjAkAlAmAnAoApAqArAsAtAuAvAwAxAyA=B{B?B@BABBBCBDBEBFBGBHBIBJBKBLBMBNBOBPBQBRBSBTBUBVBWBXBYBZB[B\B]B^BaBbBcBdBeBfBgBhBiBjBkBlBmBnBoBpBqBrBsBtBuBvBwBxByB=C{C?C@CACBCCCDCECFCGCHCICJC`CaCbCcCdCeCfCgChCiCjCkClCmCnCoCpCqCrCsCtCuCvCwCxCyC=D{D?D@DADBDCDDD`DaDbDcDdDeDfDgDhDiDjDkDlDmDnDoDpDqDrDsDtDuDvDwDxDyD=EZE[E\E]E^E_E`EaEbEcEdEeEfEgEhEiEjEkElEmEnEoEpEqErEsEtENFOFPFQFRFSFTFUFVFWFXFYFZF[F\F]F^F_F`FaFbFcFdFeFfFgFhFiFjFkFlFmFnFoFpFqFsFtFuFvFwFxFyF=G{G?G@GAGBGCGDGEGFGGGHGIGJGKGLGMGNGOGPGQGRGSGUGVGWGXGYGZG[G\G]G^G_GeGjGkGlGmGnGoGpGqGrGsGtGuGvGwGxGyG=H{HRHSHTHUHVHWHXHYHZH[H\H]H^H_H`HaHbHcHdHeHfHgHhHiHjHkHmHnHoHpHqHrHsHtHuHvHwHxHyH=I{I?I@IAIBICIDIEIFIGIHIIIJIKILIMINIOIPIQIbIcIdIeIfIgIhIiIjIkIlImInIoIpIqIrIsItIuIvIwIxIyI=J{J?J@JAJBJCJDJEJFJGJHJIJJJKJLJMJNJOJPJTJmJnJoJpJqJrJGKHKIKJKKKLKMKNKOKPKQKRKSKTKUKcKiKjKkKlKmKnKoKpKqKrKsKtKuKvKwKxKyK{L?L@LALBLCLDLELFLGLHLILJLKLLLMLNLOLQLRLSLTLULVLWLXLYLZL[L\L]L^L_L`LaLbLcLdLeLfLgLhLjLkLlLmLnLoLpLqLrLsLtLuLvLwLxLyL=M{M?M@MAMBMCMDMEMFMGMTMUMVMWMXMYMZM[M\M]M^M_M`MaMbMcMdMeMfMgMhMANBNCNDNENFNGNHNINJNKNLNMNNNPNQNRNSNTNUNVNWNXNYNZN[N\N]N^NfNgNhNiNjNkNlNmNnNoNpNqNtNuNvNwNxNyN=O{O?O@OAOBOCODOEOFOGOHOIOJOLOMONOOOPOQOROXOYOZO[O\O]O^O_O`OaObOcOdOeOfOgOhOiOvOwOxOyO=P{P?P@PAPBPCPEPFPGPHPIPJPKPLPMPNPOPPPQPRPsPuPvPwPxPyP=Q{Q?Q@QAQBQCQDQEQFQGQHQIQJQKQLQMQNQYQZQ[Q\Q]Q^Q_Q`QoQpQqQrQsQtQuQvQwQxQyQ=R{R?R@RARBRCRDRERFRGRHRRRaRbRcRdReRfRgRiRlRmRnRoRpRqRrRsRtRuRvRDSESFSGSHSISJSKSLSMSNSOSRSSSTSUSVSWSXS]S^S_S`SaSbScSdSeSfSgShSiSjSkSlSmSnSoSpSqSrSsStSuSvSwSxSyS=T{T?T@TATBTCTDTETFTGTHTITJTKTLTMTNTRTSTTTUTVTWTXTkTlTmTnToTpTqTrTsTtTuTvTwTxTyTJUKULUMUNUOUPUQURUSUTUUUVUWUbUcUdUeUfUgUhUiUjUkUlUmUnUoUpUqUrUsUuUvUwUxUyU=V{V?V@VAVBVCVDVEVFVGVHVIVJVKVLVMVNVOVPVRVSVTVUVVVWVXV[VaVbVcVdVeVfVgVhViVjVkVlVmVnVoVpVqVrVsVtVuVvV@WAWBWCWDWEWFWGWHWIWJWKWLWMWNWOWPWQWRWSWTWUWWWXWYWZW]W^W_W`WaWcWdWeWfWgWhWiWjWkWlWmWnWoWpWqWrWKXLXMXNXOXPXQXRXSXTXUXVXWXXXYXZX[X\X]X^X_X`XaXnXoXpXqXrXsXtXuXvXwXxXyX=Y{Y?Y@YAYBYCYDYEYFYGYHYIYKYLYMYNYOYPYQYRYSYTYUYVYWYXYYYZY[Y\Y_Y`YaYbYcYdYeYfYgYhYiYjYkYlYmYnYoYpYqYrYsYxYyY=Z{Z?ZAZBZCZDZEZFZGZHZIZJZKZLZMZNZOZPZQZRZSZTZUZVZWZXZZZ[Z\Z]Z^Z_ZaZbZcZdZeZfZhZiZjZkZlZmZnZoZpZqZrZsZtZuZvZwZyZ=[{[?[@[A[B[C[D[E[F[G[H[I[J[K[L[M[N[O[P[Q[R[S[T[U[V[W[X[Y[Z[[[\[][^[_[`[a[b[c[d[e[f[g[h[i[j[k[l[m[n[o[p[q[r[s[t[u[=\{\?\J\K\L\M\N\P\Q\R\S\T\U\V\W\Z\[\\\]\^\_\`\a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\u\v\w\x\y\A]B]C]D]E]F]G]H]I]J]K]L]M]N]O]Q]S]T]U]V]Z][]\]]]^]`]a]b]c]d]e]f]g]h]i]j]k]l]m]n]o]p]q]r]s]t]u]v]w]x]{^?^@^A^B^C^D^E^F^G^I^J^O^P^Q^R^S^T^U^V^\^]^^^_^`^a^b^c^d^e^f^g^h^i^j^k^l^x^y^=_{_?_@_A_B_C_D_E_F_G_H_I_J_[_\_]_^___`_a_b_c_d_f_g_h_l_m_n_o_p_y_=`{`?`@`A`B`C`D`E`F`G`H`I`M`N`O`P`Q`R`[`\`]`^`_```a`b`c`d`e`f`g`h`i`j`k`l`m`n`o`p`=a{a?a@aAaBaCaDaEaFaGaHaIaJaKaLaMaQaRaSaTaUaVaWaXaYaZa[a\a]a^a_a`aaabacadaeafagajakalamanaoapaqarasatauavawaxa=b{b?b@bAbBbCbDbEbFbGbIbJbKbLbMbNbObPbQbRbSbTbUbVbWbXbYb]b^b_b`babbbcbdbebfbgbhbibjbkblbmbnbobpbqbrbsbtbubvbwbxb=c{c?c@cAcBcCcDcEcFcGcHcIcJcKcLcMcNcOcPcQcRcScTcUcVcWcXcYcZc\c_c`cacbcccdcecfcgchcicjckclcmcncocpcqcrcsctcucvcwcxcyc@dAdBdCdDdEdFdGdHdIdJdKdLdMdNdOdPdQdRdSdTdUdVdWdXdYdZd[d\d_d`dadbdcdfdgdhdidjdodpdqdrdsdtdudvdwdAeBeCeDeEeFeGeHeIeJeKeLeMeNeOePeQeReSeTeUeVeWeXe[e\e]e^e_e`eaebecedeeefegehepeqereseteuevewexeyeAfBfCfDfEfFfGfHfIfJfKfLfMfOfPfQfRfSfWfXfYfZf[f\f]f^f_f`fafdfefffgfhfifjfkflfmfnfofpfqfrfsftfufvfwfxfyf=g{g?g@gAgBgCgDgEgFgGgHgIgJgKgLgMgNgOgPgQgRgSgTgUgVgXgYgZg[g\g]g^g_g`gagbgcgdgegfggghgigjgkglgmgngogpgqgrgsgtgugvgwgxgyg=h{h?h@hAhBhChDhEhFhGhHhIhJhKhLhMhNhOhPhQhRhShThUhVhWhXhYhZh[h\h]h^hehfhghhhihjhkhlhmhnhohphqhrhthuhvhwhxhyh@iAiCiDiEiFiGiHiIiJiKiLiMiNiOiPiQiRiSiTiUiViWiXiYiZi[i\i]ibicidieifigihiiijikipiqirisitiuiviwixiyi=j{j?j@jAjGjHjIjJjKjLjMjNjOjPjQjSjTjUjVjWjXjYjZj[j\j]j^j_j`jjjkjljmjnjojpjqjrjsjtjujvjwjxjyj=k{k?k@kBkCkDkFkGkHkIkJkKkLkMkNkUkVkWkXkYkZk[k\k]k^k_kakbkckdkekfkgkhkikjkkklkmknkokpkqkukvkwkxkyk=l{l?l@lAlBlClDlElFlGlHlIlJlKlLlMlNlOlPlQlSlTlUlVlWl\l]l^l_l`lblcldlelflglhlilklllmlnlolplqlrlsltlulvlwlxlyl=m{m?mImJmKmLmMmOmPmQmRmSmTmUmVmWmXmYmZm[m\m]m^m_m`mambmcmdmemfmgmhmimjmnmpmqmrmsmtmumvmwmxmym=n{n?n@nAnBnCnDnEnGnHnInJnKnLnMnNnOnPnQnRnSnTnUnYn[n\n]n^n_n`nanbncndnenfngnhninjnknlnmnpnqnrnsntnunvnwnxnyn=o{o?o@oAoBoCoDoEoFoGoHoIoJoKoLoMoNoOoPoQoRoSoToUoVoWoXoYoZo[o\o]o^o_o`obocodoeofogohoiojokolomonooopoqorosotouovowoxoyo=pApBpCpDpEpFpGpHpIpJpKpLpMpNpOpPpQpRpSpTpUpVpWpXp\p]p^p_pepfpgphpipjpkplpmpnpoprpspupvpCqDqEqFqGqHqIqJqKqLqMqNqOqPqQqRqTqUqVqWqXqYqZq[q\q]q^q_q`qaqbqcqdqeqfqgqhqnqoqpqqqrqsqtquqvqwqxqyq=r{r?r@rArBrCrDrErFrGrHrIrJrKrLrMrNrOrPrQrRrSrTrUrVrWrXrYrZr[r\r]r^r_r`rarbrcrdrerfrmrnrorprqrrrsrtrurvrwrxryr=s{s?sAsBsCsDsEsFsGsHsIsJsKsLsMsNsOsPsQsSsTsUsVsWsZs[s\s]s^sbscsdsesfsgshsiskslsmsnsosps=t{t?t@tAtBtCtDtEtFtGtHtItJtKtLtMtNtRtStTtUtVtWtXtYt[t\t]t^t_t`tatbtctdtetftgthtitjtktltmtntotptqtrtstttutvtwtxtyt=u{u?u@uAuBuCuDuEuFuGuHuIuJuKuLuMuNuOuPuQuRuSuTuUuVuYuZu[u\u]u^u`uaubucudueur:{=?=@=A=B=C=D=E=F=G=H=I=J=K=L=M=N=O=P=Q=R=S=T=U=V=W=X=Y=Z=[=\=]=^=_=`=a=b=c=d=e=f=g=h=i=j=k=l=m=n=o=p=q=r=s=t=u=v=w=x=y=={?{@{A{B{C{D{E{F{G{H{I{J{K{L{M{N{O{P{Q{R{S{T{U{V{W{X{Y{Z{[{\{]{^{_{`{a{b{c{d{e{f{g{h{i{j{k{l{m{n{o{p{q{r{s{t{u{v{q?r?s?t?u?v?w?x?y?=@{@?@@@A@B@C@D@E@F@G@H@I@J@K@L@M@N@O@P@Q@R@S@T@U@V@W@X@Y@Z@[@\@]@^@_@`@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@s@t@u@v@w@x@y@=AJAKALA_B`BLCMCNCOCPCQCRCSCTCUCVCWCXCYCZC[C\C]C^CFDGDHDIDJDKDLDMDNDODPDQDRDSDTDUDVDWDXDYDZD[D\D]D^D_D?E@EAEBECEDEEEFEGEHEIEJEKELEMENEOEPEQERESETEUEVEWEXEYEuEvEwExEyE=F{F?F@FAFBFCFDFEFFFGFHFIFJFKFLFTG`GaGbGcGdGfGgGhG?H@HAHBHCHDHEHFHGHHHIHJHKHLHMHNHOHPHQHRISITIUIVIWIXIYIZI[I\I]I^I_I`IaIQJRJSJjJkJsJtJuJvJwJxJyJ=K{K?K@KAKBKCKDKEKFKWKXKYKZK[K\K]K^K_K`KaKbKdKeKfKgKhKPLiLHMIMJMKMLMMMNMOMPMQMRMSMiMjMkMlMmMnMoMpMqMrMsMtMuMvMwMxMyM=N{N?N@N_N`NaNbNcNdNsNTOUOVOWOjOkOlOmOnOoOpOqOrOsOtOuODPSPTPUPVPWPXPYPZP[P\P]P^P_P`PaPbPcPdPePfPgPhPiPjPkPlPmPnPoPpPqPrPtPOQPQQQRQSQTQUQVQWQXQbQcQdQeQfQgQhQiQjQkQlQmQnQIRJRKRLRMRNRORPRQRSRTRURVRWRXRYRZR[R\R]R^R_R`RkRxRyR=S{S?S@SASCSPSQSYSZS[S\SOTPTQTYTZT[T\T]T^T_T`TaTbTcTdTeTfTgThTiTjT=U{U?U@UAUBUCUDUEUFUGUHUIUXUYUZU[U\U]U^U_U`UtUQVYVZV\V]V^V_V`VwVxVyV=W{W?W[W\WsWxWyW=X{X?X@XAXBXCXDXEXFXGXHXIXJXgXhXiXjXkXlXmX]Y^YtYuYvYwY`ZxZv[w[x[y[@\A\X\Y\q\r\s\P]R]W]X]Y]_]y]=^K^W^X^Y^Z^[^m^n^o^p^q^r^s^t^u^v^w^K_L_M_N_O_P_Q_R_S_T_V_W_Y_e_i_j_k_q_r_s_t_u_v_w_x_J`K`S`T`q`NaOaPahaiayaHbZb[b\b^c?d]d^dedkdldmdndxdyd{e?e@eYeiejekelemeneoe=f{f?f@fbfcfWg_h`hsh=i{i?iBi^i_i`iliminiejOkPkQkRk`kRl@mCmNmkmlmmmomFnaoYpZp[pppqptpSq@sRsqsrsQtXYZ[\]^_`abcdefghijklmnopqrstuvwxy={?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxy={?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^3~RST_`abcdefghijklmnopqrs]tuvwxy={?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`^)*+ abcdefghijklmnopqrstuvwxy={?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqIJKrstuvwxy={?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[_EFGH\]^_`abcdefghijklmnopqrstuvwxy=	{	?	@	y={?A	B	C	D	E	F	G	H	I	J	K	L	M	N	O	P	Q	R	S	T	U	V	W	X	Y	Z	[	!3\	]	^	_	`	a	b	c	d	e	f	g	h	i	j	k	l	m	n	o	p	q	r	s	t	u	v	XYZaw	x	y	=
{
?
@
A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P
Q
R
S
T
U
V
W
X
Y
Z
[
\
]
^
_
`
a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x
y
={?@ABCDEFGHIKLMNOPQRSTUVWXYZ[\bcdefghijklmnopqrstuv]^_`abcdefghijklmnopqrstuvwxy={?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[	
\]^_`abcdefghijklmnopqrstuvwxy=~{~?~@~A~B~C~D~E~F~G~H~I~J~K~bcdefghijklmnopqrstuvL~M~N~O~P~Q~R~S~T~U~V~W~X~Y~Z~[~\~]~^~_~`~W(b~c~d~e~f~g~h~i~j~k~l~m~n~o~p~q~r~ws~t~u~v~w~x~y~={?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxy=_STUV{?@ABCDEFGHIJKLMNOPQRcSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxy={x?@ABCDEFGHIJKLMNOPQR4STUVWXYyZ[\]^_`abcdefghijk!lmnopqrstuvwxy={?@ABCDEFGIJKLMNOPrstuIJKLMNOPQRSTUVWXYZ[\]^_`abcdefg=hijklmnopqrstuvwxy={?@Awx7ef9:;|={CDEFGHI{JKLMNOPQRSTULMNOPQ?VWXYZ[\]^_`a)*+ bcdefghijklmnopqrstuvwxy={?H@ABCDEFGHIJKLMNOPQRSTUVWXYZB[\]^_`aJKbcdefghijklmnopSTUVqrstuvwxy={?@A,-."BCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstYZ[uvwxy={?@ABCDEFGHIJKLM9:;|={NOPQRSTUVWXYZ[\]^!_`abc@defghijkl6mnopqrstuvwxy={?ABC#ABC#~NOPQR@ABCDEFGHIJKLMNOPQRSTUVDEFGHNOPQRWXYZ[\]^_`abcdefghijklmno7pqrstuvwxy={?@ABCDEFGHIJKLMNOPQRSTUVWXY	
Z[\]^_`abcdefghijklmnopqrstuv$wxy={?@ABCDE%FGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmno`pqrstuvwxy={?@ABCDEFGHIJKLMNOPQRLMSTUIJKLMNOPVWXYZQ[\]^_`abcdefghijklmn]opqrstuvwxy/012={?@A6STUVBCDEFGHIJKLMNOPLMQRSTUVWXYZ[\]^_`abc5defghijklmnopqrstuvwxy={$?@WABXYZaCDEFGHIJlmnopKLMNOPQRSTUVWXYZ[EFGH@\]^_`abcdefghijk[\]^_`ab5lmnopDqrstuvwxYZ[y={?@BCDEF'~ABCDEFGHIJKLMN$~OPQRST#/09:;|={UVWXYZ[\]^_`abcdefghij[\]^_`ab5klmnopqrstuvwxy={STUVj?@ABCDEFGHIJKLMNOPQRSTUh'VWXYZ[\]^_`abcd\efghijklmnopqrstuvwxy={J?@ABCa~DEFGHIJKLMNOPQRSTUVWXY6Z[\]^_c`abcdefghijklmnopqrstuvw%xy={?@}AdBCDEFRGHIJKLMNOPQRSTUVWXYZ[\ef]^_`abcdefghijklmnopqrstuvwxyi= { ? @ A ?B C D E F ABCD8G H I J K L M N O EFGH@ABCD8P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g 12h i j k l m n o p q r s t u v w x y =!{!?!@!A!B!,-."WX}C!D!E!F!G!H!I!J!K!L!M!N!O!P!Q!R!S!T!gh'iU!V!W!X!Y!Z![!\!]!^!_!IJK`!a!b!c!d!e!f!g!h!i!j!!k!l!m!n!o!p!q!r!s!t!u!gv!w!x!y!="{"?"@"A"B"C"D"E"F"G"H"I"J"K"L"M"N"O"P"Q"R"W~S"T"U"V"W"X"Y"Z"["\"]"^^"_"`"a"b"c"d"e"xf"g"h"i"j"k"l"m"n"o"p"q"r"s"t"u"v"w"x"y"=#{#?#@#A#B#C#D#E#F#G#H#I#J#K#L#M#N#O#P#Q#R#S#T#U#V#W#X#Y#	
ABCD8Z#[#\#]#^#_#`#a#b#c#d#e#f#g#\h#i#j#k#l#m#n#o#	
p#q#r#s#t#u#v#w#x#y#=${$?$@$A$B$C$D$E$F$G$H$I$J$K$L$M$3GHIjN$O$P$Q$R$S$T$U$V$W$4/0X$Y$Z$[$\$]$^$_$`$a$b$c$d$e$f$lmnopg$h$i$j$k$l$m$n$o$p$q$qr$s$Rt$u$v$w$x$y$=%{%?%@%A%B%rstuEFGH@C%D%E%F%G%H%I%J%K%L%M%N%O%P%Q%R%S%T%U%V%(W%X%Y%vZ%[%\%]%^%_%`%a%b%)*+ ~wx7c%d%e%f%g%h%i%j%k%l%m%n%o%p%q%r%s%t%u%v%w%x%y%=}{}?}@}A}IJKB}{C}D}E}F}G}H}I}J}K}L}M}N}O}P}Q}R}S}T}U}V}W}X}Y}Z}[}	
\}]}^}_}`}y={?a}b}c}d}e}@f}g}h}i}j}k}l}m}An}o}p}q}r}s}t}u}v}w}x}y}='{'?'@'A'B'	
LMBCDEF'C'D'E'F'G'UVH'I'@J'K'L'M'qN'O'P'Q'R'kS'T'U'V'W'X'Y'Z'['\']'^'_'`'a'4b'c'~d'e'f'g'h'i'j'k'l'm'n'o'p'q'r's't'u'v'w'yx'y'=({(?(@(A(B(C(D(E(F(G(H(I(GHIJ(dK(L(M(N(kO(P(Q(R(S(T(U(V(W(X(Y(Z([(\(](wJK^(_(`(a(%b(c(d(e(f(g(h(vi(j(k(l(m(n(o(p(q(r(s(t(u(v(w(x(y(=){)?)@)A)B)C)D)E)F)G)H)I)J)K)L)M)N)@,-."O)P)Q)R)S)T)U)V)W)X)Y)Z)[)\)])^)_)`)a)b)c)d)e)f)g))*+ h)#i)j)k)l)m)n)o)p)q)`r)s)t)u)v)w)x)y)=*{*?*@*A*B*	
WX}C*D*E*F*NOPQRG*H*I*J*K*L*M*N*O*P*Q*~R*S*	
T*U*,-."LMNOPQ?V*W*X*Y*Z*[*\*]*^*_*`*a*b*c*d*e*	
f*g*h*i*j*k*l*m*n*o*p*q*r*s*t*u*v*w*x*y*=+/0RST{+$?+@+A+B+C+D+E+F+G+H+%I+J+K+L+M+N+O+P+Q+R+S+T+U+V+W+X+Y+Z+[+\+]+^+_+`+a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p+q+r+s+STUVUVt+u+v+(w+x+y+=,{,?,@,A,B,C,D,E,F,~G,H,I,J,K,L,M,?N,O,P,Q,R,S,T,U,V,W,	
X,Y,Z,[,\,WX}],^,_,`,a,YZ[b,=c,d,e,f,g,h,i,?W(j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,=-{-?-@-A-B-C-D-12E-F-G-H-I-J-K-L-\M-N-O-P-Q-R-S-T-U-V-W-X-Y-Z-A[-\-]-^-_-`-a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-=.{.?.@.A.B.C.D.E.QF.G.H.	
I.J.K.L.M.N.O.P.Q.R.S.T.~128//;$:2E</pre>
</div>
<div style="display:none">
	<pre id="methods">SANRS8801#02$\r}5s(^_314xy`st7uvT*7RS#RYZ["'a
RSUV|WXo 
A 84AX-?!S^4S[S[{y
Uf.fq*gonpq-[S{6b8cdeon,LY_{U]O$7gq*hi 9(klmn2rs=WZ{Z[]^{?2={,	PQ8j 
rs2tu/TfP5]{

85$;=6{@0CE5FG6oq7w8NO$\8xyYLE|Z[Z\913:%
;5~:#4;|ABCD;~op?vuwxy=A@?B	-IJIJ9/^_)`a
/`b`c~pqUV8 sl65275}02,?@ "HD3KJ2W\]\ 3`d\=y4@ ~3@!XKJ %fg	Hm:Im4.IJ uK`d)?'455	fb/7gh=8y{CD8ED	FGKJ$WZ*W[{?)]^sb-sb~.Uk1:
LF
	fQ	tu|6iS!EF*GmA 
S^5o :

`cS	T	?
@
{|;
4#FG(kbkb|y=:%on~WY9g\j\*(d{y
VX)=YZtu3]^;s_~?`a.cP,lm$6vw2vx;Z_/Slyv
wx,hy{y~?y{y~IH
	UP	GP4lnU\{P	M	Q	M
d	KJ$}H~[~H~	+[ 
)~~?KLce7ijkmLMNM~UV)WX`e*g\	h\7i\	 jdsv4GP	8NOVW 3|+[1cd
ghvy=A@!RMN\[{\^Z_`aEDGHfg?	=y	GH.'sb#UPUV|8WVde3jS8kSsS~gm
(W~P\
=SQ{mn.o\$_`5'M	M5O	MQ	R	`	a	-c	k	ko	"]^:Q	R	,Cu?m
\=v\}TUgm*sv5swsl	cqO~f	R~ X~H	ij0
KwxA
y~=I}OP3(?(?)k
%	 4}'/()(*
+,7.JIST[\;{]^9%_`$%cd!klf\'"S$.$S3TU+ed39ef+
sI.sP+sP:op5?@':LK
TS3~TS|TU|
+V'WV=Z[Z[?\]7hi0y=MasI8myu
)	C{0W~+WX7fg7hS{iQ{LMNO)PQ
R\-S\47ST7	UVUaWY~7bcfgij2kl)kltx14N	MS	m~U	T	'9wx.b	c	:l	65/6m	4kn	!p	q	?
@
?wxR
S`=d
e
}EMa"M7qMrMsM{sM+
st:
suw
\}	w
Q+2v\:vw	UV;6Z[9V]cd	sb%OPOQ6N~P~Q~S~*T~U~e	R~%f	V~W~Q,xy(uP~Af -Z
	}Ws,WK~,WK,{UV
~A
B
-C
{?^K?0Jpyo\{O?'m
t_ny
qYL1YR2(y
LNM"nb(4?~-,HI(MN
4MO)U{@(){V}ab3nb(HI
Hp:qr)EF

HIJKLM LM
R"S!sv=tu4o{6#AB{%CB#~DB"5EB7FH$SK
KL~~KO	,R+	S9SR=`aIJ'hija!kP9+k?KL/KJ/2OPQP7WXWY*gh)wu/@A1@B~Ew2Gw7HI9JLCE0oOPQRQUVpqWs{*Wu"vw4@AdB}fC	+	A /2AK!}NM0WS`-?U{/de!1st"/sx~ij~3{	?	{	j
"~{	@	A	C	@F	V	}?@
e	S%f	S"HSh	i	=
{
1.?
w::F
a.O
P
* y{*
`	a	AX%W
X
;Y
Z
Y
[
_
a
b
c
2f	S!s_s_%p
q
p
q
,CDMN|MS#%TU.TV4]^C
iABU	T	2U=%?	l{%py'{	I,HI'Q	t?U	T	?IqJ%}rJX!"YZ[\gm*$S=:r	q	,s	_4s	_9bcZf(gP'hi="si4PQ3jk lk#mn "Uo (WY5WY"V	?
@
S=~{~,1`Py_	#'y=~M~Q~R~ed39Y~Z~1~[~\~.Kt~Ku~
\	v~w~x~=?AWZ~uKp
Xp
Xkn	|Ad0	Aeuv'M
N
st%LMNOPO90PQTS$	lF:;=,aP*fg?	hIs	$yQ
:|sPsB#ST	ed	0NOGP?{Uy+qr~)sW0sW~sW#XY*6gq5nL{vw6v~;*r	s	1C
= snsJ9UV:}`a ef+
=
Vo,9
xy9
x='wx!@AKgm?-k	de	GH.l?2{??sv+Qr'$SZ	
*y_	';]|CD
1w
{)v{vBS^-2QCu"m
tZtw
o$-w
p,qrIm}M	m5':)2')
~ 
 !=!"#!"#7$#{'$%3/KL-PQ3RQ)WV|WX#;	YZ#={?@AB
AC
AC
DE
#DF |	DG~0DH :IJ4KLMOPOQ6RS65kl.mnmost;su".sv$sw3A ( BC~ BD}wxPLM"QsijI$RI*lnlo$poqr"DBFG~~II';JI:su)PQ
PP3ba~bc"defQ	fg	kl{mn) op	|qr2=
st6
su|sv	Sw
\[}xy6	='({!klm@*mA
BC	BD	GH
IH
	KLMN"RS}RSRT5UV$kP%GP	87Z[-
W\"]^_`:VW1|YaJI50bc+=defghijk85!8n0op/qp1qr1st"stsw),CD3Fw.HwHIKSKSM
-KJ;;NLST*WY0WZ[\JI9J]=*^_)`_(`_a_6ab	!f_	}fc7A@|3An|Uo|Sr}%Wt~6vw(xy-={OP3O?'vw2yv
LE|LF
	KJ42fD;	tu}7thpyqr*
/,Cu!G_8n1vw"sx:ty"i=	-A	B	o 
D	E	(G	H	I	J	:I	K	(I	L	++W	X	$Y	Z	!4[	B[	#5|KO\	]		
{	^	5({	^	~)y_	'g	Kh	`	j	
r	q	%s	t	?u	v	#u	w	9x	Cjy	66Sw
=
=
VA
B
(2A
w?C
D
 6E
a6F
G
 6jy	7r"rH
	I
H
!J
K
L
K
#rr
Cu/,M
N
,yQ
:|uKb	c	:310!oS
	6qS
{~LT
-	LU

Z{6V
W
P'~-Z
,-\
]
tu3]^^
`
wxd
e
!f
ln
~lg
#qh
	t_ 	i

/@j
4 W
k
l
w
m
n
}o
r
s
%t
u
:t
v
	w
x
+y
=y
=
y
{?@AA@BFGHIJKL6m	1OP6kwQR RWXW|XY~{	I,S`Z[*Z\ fg4|GP4{?+_`.a`bw!*bcde*fe9
?
@
$A
g+C
h-jkl
km2}no'np7}@x~	@y%l?l@8AB7	qr*qrCaCDEF		Gy5sJ9sM+
W\d_6f_}J].KL"KM7oNqN!OP=sw.sQ!5r
s
t
R"WS=
V	WjS"^`a0dw	be

S`|LU
 
}STWpr5)sw=,A
t~C
uC
vwxy#6?~@~!A~B~C~
\]~xD~	`P(E~Pfg	F~b"F~b	F~G~{;F~h.'d
e

$=H~#(I~J~K~*ty/"]L~xyw
Q	:_`]]~o^~ q^~/!_~^~(	.6}'/AX(~9#A`~+La~0{	w(]^b~c~!b~r4^d~0`d~3ad~$E~d~#e~Lb~f~"6g~h~~i~h~}i~j~~i~k~{Hh~KL[L]L.]l~1m~n~}si4sP:o~LM0p~q~$	r~s~QKLQP0\	v~jy	66w~y~{@BCDEFGHIJKLSR"465
0kM	Nw#OP.C{{	Q?sR%SWY3$TwTw=UV/UV=UV"WPo
?YL*YJ*6ZJsw-*A
[\]4\^'_`6_`96$Y~Z~4~Y~abcA *Af
 gR?hR\^?iP
jk
kl.lm(lm'ln%oQ}*pD
`a	0qrvu?st~av2av/fv	fD 
fw=S,
7{
U	?*@`+@`AB')AC2AD/AEE
w*F
w}ln~lF9\]/4oG
qG*/qH?bI~JCPR2STU1S	T	iV'iW6HH	qXt_ 	de
YZ:SB0yv+
Y[
Y\9	;]%{o^q^G	T		U	T	s^
C_`a-ba`c++dJ	!dK	$3de$~fg\^Z_ABkl
ST#W
C6W
i;-j	~-k	-l3msn'ofb3M	pM	qRSx	w5!E
Rrstuvwxy={?@Ap
q
02_0tx2,CE
CD-EFGH,aP*aI{	J~:hJ.RQ}WK=WL9eM"?PU,4HIQRSF
T{tx!xyx	A1de0sVsv	ZS3KL~[\$]^2_G-`L]a
b_km;)noqr3-cdef3efA ,Ag{Ae4%Ah#	LiQ	t2dejk5lm:UV+%kP9+kl?o5	pq=*ra~{ra~RS4(Z[$r	q	"mm	:tw	.uH
vw.4x@ABC~!)#DE*5FE?B-,PP?^PaP*aI{	J~:ba	bGbc JI'JH
JIJI]^KL*Kv	2Kv	7u	v	~6u	v	u	w	stuw
.aw#aw1M=H~#TV'4NOWp#PQ	WPijM	RST#fg	fQ	Ur~VW!XaXY#	Zy[y6\y5Z[;-Z]T_cP,cd
@A}(_`abcdefAX	9"gh}sI78;=;i|jk"-tx"'de	dH7Z[4ZlZmv@UV0%~+=I%KJ"1]Lno
 9cpqr"qsqtd
e
.-='({!J~u/t_.	vvstwv\x{6~BCr	q	/~Dn	'EB0Fv=FG)
FHICur}+qL;q\	pM
{	N
hOPQ\]`a2'`w;3`l4RSSS7jS"PiI{LM/{	T9$6m	(sI)V	5!OUV		VWXWYw3Zw	$iWA [t%l{	\]4^]-_y_y`Z	#
aZ	~ab(1cZ	0+'dZ	.5E
a=F
a~he26@Afwjk5fg7ghifjfk -lm'nm"oB(}YL
Yp(w
w0y
q	;y
rshI0p
X#tI.uI ?`I~bI$jI})kv!8av
fD8{	-w%-xG	H	yH	E~h
0E=~@?@?9/AB3CDEFGH!
IF
IFcJ?PU
0PK	sb!65;oL\[;WM	bN5OPpyQr{	R	2SZ	8*S`"+Q	R	9%Q	T
Q	h
	~Q	U]O$7^_@?$VW :X_\^:fP5Af'
 Yj{	@	ZfP5hS{BCR[\KL} K]sveM=^l{|A@21A_
`a)bc	de:fgfh%ij	2ik6lj;IJ~(Im~4wn$ynww+V	"?qo.Pp2DBeM4	PU+y_	'-w'-q'fP5O
mHD,
]^#s_{lnlrpr{x{~{sRtuvWKSw3Sw
:de
YZ:{	e3/{	x0)hxhx$ A@7y=05K{o{0q{y{g\hM@M?kwkA9!m
{w
^0}v{3CE72CD1M	M2M	E#F\O	\P	\~}Q	\#Q	d9Q	a
Q	G81Q	H"W
I$jy	66Jy=7e	K%f	K3LP1t_(	vh
vvvMNOPe	R2(*
+,5hS~8#r%I
TUVeM"?NOtu3Ww!XwYw%Zw0jI4jI) .iI{aw2fP5kl=|k[\J1]Lk^p	_r	_`lE_F_?@8SB0A@+G	H	+OH	7aH	={bc=d~){	y'/eyefew%'XYgH	;hHi	~~Cj*1B	(
k~
Zlvm6m	?qG#fP5s(st)uvst2	OP+x	I3%	LMx{0uvx	A1dC9S$fD
XI~Xw6x'7@x:	XW5{	IMS~$_yWV"y= j{Gm
?sl	fD8{	E~@su7*AB	C5PD	PDgh1gE+jI4.?B%UVFG"FG2PHPI{J-~KL" IM/@?{@N@?%S^/SO\^#\D=PQsb%MS#%TU.STUVWwxjXmA
BC	KL%KYKZR["
R\9	R]	X^b_'	be
dS*ghK?
Y	Z	3`Z	)aZ	aZ	|'ba!F
G
7F
ckdU=
Ue,
fg9GH3|o6AX~"Lh+S`"+{	x +'hx~:TUTi)jyM	lfb	/M	n opty
CE%:Cq|uKp
q
#CwswrPQ%LMsM9tMtu2vM
tw	9wxiWty-
=_{	._?HpH@1"AE</pre>
</div>
<span class="status" style="border-right: none; border-top-left-radius: 4px; right:0;">
	<span id="produced">Produced by <a href='https://github.com/async-profiler/async-profiler'>async-profiler</a>&nbsp;</span>
	<span id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span>
</span>
<h1 id="title">Flame Graph</h1>
<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>
<div id='preview_wrapper'><canvas id='preview'></canvas></div>

<span id='status' class="status" style="border-left: none; border-top-right-radius: 4px; display: none; left:0;">&nbsp;</span>
<script>
	// Copyright The async-profiler authors
	// SPDX-License-Identifier: Apache-2.0
	'use strict';

	let dR, dG, dB;
	let dRs, dGs, dBs;
	let dRdg, dGdg, dBdg;
	let dRdl, dGdl, dBdl;

	function setH(H) {
		const dX = Math.round(256 - Math.abs(H % 2 - 1) * 256);
		switch (H | 0) {
			case 0:
				dR = 256; dG = dX; dB = 0;
				break;
			case 1:
				dR = dX; dG = 256; dB = 0;
				break;
			case 2:
				dR = 0; dG = 256; dB = dX;
				break;
			case 3:
				dR = 0; dG = dX; dB = 256;
				break;
			case 4:
				dR = dX; dG = 0; dB = 256;
				break;
			case 5:
				dR = 256; dG = 0; dB = dX;
				break;
		}
	}

	setH(0.4);

	dRdg = dR;
	dGdg = dG;
	dBdg = dB;

	setH(2.4);

	dRdl = dR;
	dGdl = dG;
	dBdl = dB;

	setH(3.4);

	dRs = dR;
	dGs = dG;
	dBs = dB;

	setH(0.4);

	let root, rootLevel, px, pattern;
	let showFound = false;
	let filterFrames = false;
	const levels = [];

	const canvas = document.getElementById('canvas');
	let c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const preview_wrapper = document.getElementById('preview_wrapper')
	const status = document.getElementById('status');

	const canvasWidth = canvas.offsetWidth;
	let canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

	let lastRenderFrom = 0;
	let lastRenderTo = 0;
	let lastBaseRenderFrom = 0;
	let lastBaseRenderTo = 0;
	let renderFunc = renderSelfDominators;
	let renderFuncDiff = renderTracesDiff;

	for (let mode of ['flame-mode-flame', 'flame-mode-reversed', 'flame-mode-methods']) {
		document.getElementById(mode).onclick = () => {
			selectMode(mode);
		};
	}

	document.getElementById('flame-diff-reverse').onclick = () => {
		if (heatDiffSample1 !== -1) {
			renderWrapperDiff(lastBaseRenderFrom, lastBaseRenderTo, lastRenderFrom, lastRenderTo);
		}
	};

	document.getElementById('search').onclick = () => {
		search(true);
	};

	document.getElementById('filter').onclick = () => {
		search(true, true);
	};

	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x20d120, 50, 45, 50],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30, 0],
		[0xcce880, 20, 20, 20]
	];

	function getColorStable(p, i) {
		i = Math.imul(i, 0xcc9e2d51);
		i = Math.imul((i << 15) | (i >> 17), 0x1b873593) >>> 24;

		const v1 = (p[1] * i) >>> 8;
		const v2 = (p[2] * i) >>> 8;
		const v3 = (p[3] * i) >>> 8;
		return '#' + (p[0] + (v1 << 16 | v2 << 8 | v3)).toString(16);
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrameIndex(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return mid;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return left;
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return right;

		return -1;
	}

	function findFramesBetween(frames, xFrom, xTo) {
		const result = [];
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > xFrom) {
				right = mid - 1;
			} else if (f.left + f.width <= xFrom) {
				left = mid + 1;
			} else {
				left = mid;
				break;
			}
		}
		for (let i = left; i < frames.length; i++) {
			const f = frames[i];
			if (f.left > xTo) {
				break;
			}
			result.push(f);
		}

		return result;
	}

	function findFrame(frames, x) {
		const index = findFrameIndex(frames, x);
		if (index === -1) {
			return null;
		}
		return frames[index];
	}

	function findNextFrame(frames, x) {
		const index = findFrameIndex(frames, x) + 1;
		if (index === 0 || index >= frames.length) {
			return null;
		}
		return frames[index];
	}

	function findPrevFame(frames, x) {
		const index = findFrameIndex(frames, x) - 1;
		if (index < 0) {
			return null;
		}
		return frames[index];
	}

	const marked = [];

	function render(newRoot, newLevel, minLevel) {
		minLevel = minLevel || 0;
		if (root && minLevel === 0) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		rootLevel = newLevel || 0;
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;

		if (minLevel === 0) {
			marked.length = 0;
		}

		function mark(f) {
			return marked[f.left] >= f.width || (marked[f.left] = f.width);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function (a, b) {
				return a - b;
			}).forEach(function (x) {
				if (+x >= left) {
					total += marked[x];
					left = +x + marked[x];
				}
			});
			return total;
		}

		function drawFrame(f, y, alpha) {
			if (f.left < x1 && f.left + f.width > x0) {
				let match = showFound && pattern(f.method) && mark(f);
				const fw = f.width * px;
				if (fw < 0.1) {
					return;
				}
				c.fillStyle = match ? '#40b2ff' : f.color;
				c.fillRect((f.left - x0) * px, y, fw, 15);
				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
				}

				if (alpha) {
					c.fillStyle = 'rgba(255, 255, 255, 0.25)';
					c.fillRect((f.left - x0) * px, y, fw, 15);
				}
			}
		}

		for (let h = minLevel; h < levels.length; h++) {
			const y = h * 16;
			const frames = levels[h];
			for (let f of frames) {
				drawFrame(f, y, h < rootLevel);
			}
		}

		return totalMarked();
	}

	let previewX = -1;
	let previewY = -1;

	function showPreview() {

		const w = 500;
		const h = 15 * 16;
		const s = 50;
		const dx = w / s / 2;

		preview_wrapper.style.left = (canvas.offsetLeft + Math.max(0, previewX - w - 8) - 4) + 'px';
		preview_wrapper.style.top = (previewY + canvas.offsetTop - h - 16) + 'px';
		preview_wrapper.style.display = 'block';

		let xFrom = (previewX - dx) / px + root.left;
		let xTo = (previewX + dx) / px + root.left;
		if (xFrom < 0) {
			xTo -= xFrom;
			xFrom = 0;
		}
		const preview = document.getElementById('preview');
		preview.style.width = w + "px"
		preview.style.height = h + "px";
		preview.width = w * (devicePixelRatio || 1);
		preview.height = h * (devicePixelRatio || 1);
		const c = preview.getContext('2d');
		if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
		c.font = document.body.style.font;
		c.fillStyle = '#ffffff';
		c.fillRect(0, 0, w, h);
		for (let i = 0; i < 15; i++) {
			const level = Math.floor(previewY / 16) + i - 7;
			if (level < 0 || level >= levels.length) {
				continue;
			}
			const frames = findFramesBetween(levels[level], xFrom, xTo);
			const x0 = xFrom;
			for (let f of frames) {
				const fw = f.width * s * px;
				c.fillStyle = f.color;
				c.fillRect((f.left - x0) * s * px, i * 16, fw, 15);
				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, (f.left - x0) * s * px + 3, i * 16 + 12, fw - 6);
				}
			}
		}
		c.strokeRect(0, 7 * 16, w, 16);
	}

	canvas.onmousemove = function (e) {
		previewX = e.offsetX;
		previewY = e.offsetY;
		if (e.shiftKey) {
			showPreview();
		} else {
			preview_wrapper.style.display = 'none';
		}

		const h = Math.floor(e.offsetY / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], e.offsetX / px + root.left);
			if (f) {
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = (h * 16 + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				let details = f.details || '';
				canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function (e) {
					if (e.shiftKey) {
						e.preventDefault();
						searchForMethod(f.method);
						canvas.onmousemove(e);
						return;
					}

					if (e.ctrlKey) {
						const n = e.shiftKey ? findPrevFame(levels[h], e.offsetX / px + root.left) : findNextFrame(levels[h], e.offsetX / px + root.left);
						if (n) {
							render(n, h);
						}
						canvas.onmousemove(e);
						return;
					}

					if (f !== root) {
						render(f, h);
						canvas.onmousemove(e);
					}
				};
				status.textContent = 'Function: ' + canvas.title;
				status.style.display = 'inline';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function (e) {
		hl.style.display = 'none';
		status.textContent = '\xa0';
		status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = '';
		if (e !== undefined) {
			preview_wrapper.style.display = 'none';
			previewX = previewY = -1;
		}
	}

	document.getElementById('reset').onclick = function () {
		search(false);
	}

	class DataBuffer {
		data;
		pos = 1;

		constructor(encodedData) {
			this.data = encodedData;
		}

		nextVarInt() {
			let res = 0;
			let shift = 1;
			let b;
			do {
				b = this.byteAt(this.pos++);
				res += (b % 61) * shift;
				shift *= 61;
			} while (b >= 61);
			return res;
		}

		nextBase123() {
			return (Math.imul(this.byteAt(this.pos++), 1860867)	// 123^3
				+ Math.imul(this.byteAt(this.pos++), 15129)     // 123^2
				+ Math.imul(this.byteAt(this.pos++), 123)       // 123^1
				+ this.byteAt(this.pos++)) | 0;                 // 123^0
		}

		byteAt(pos) {
			const c = this.data.charCodeAt(pos);
			switch (c) {
				case 127:
					return 0;
				case 126:
					return 13;
				case 125:
					return 38;
				case 124:
					return 60;
				case 123:
					return 62;
			}
			return c;
		}

		nextInt6() {
			return this.byteAt(this.pos++);
		}

		nextInt18() {
			return this.nextInt6() | this.nextInt6() << 6 | this.nextInt6() << 12;
		}

		int30(pos) {
			let p = pos * 5;
			if (p < 0) {
				p += this.data.length - 1;
			}
			return this.byteAt(p++) << 0
				| this.byteAt(p++) << 6
				| this.byteAt(p++) << 12
				| this.byteAt(p++) << 18
				| this.byteAt(p++) << 24;
		}
	}

	function decodeExecutions(data) {
		const samplesCount = data.int30(-1);
		const chunksCount = data.int30(-2);
		const storageSize = data.int30(-3);
		const blocksCount = data.int30(-4);
		const lz78RecordsCount = data.int30(-5);

		const starts = new Set();
		const startMethodsCount = data.nextVarInt();
		for (let i = 0; i < startMethodsCount; i++) {
			starts.add(data.nextVarInt());
		}

		// NOTE: All dynamic allocations should be done before this line
		const buffer = new ArrayBuffer((4 + 4 + 4 + 4 + 4) * lz78RecordsCount);
		const lz78RootMethods = new Uint32Array(buffer, 0, lz78RecordsCount);
		const lz78CurrentMethods = new Uint32Array(buffer, lz78RecordsCount * 4, lz78RecordsCount);
		const lz78Parents = new Uint32Array(buffer, lz78RecordsCount * 8, lz78RecordsCount);
		const lz78Sizes = new Uint32Array(buffer, lz78RecordsCount * 12, lz78RecordsCount);
		const lz78Refs = new Uint32Array(buffer, lz78RecordsCount * 16, lz78RecordsCount);

		const storageMarksIntsCount = (storageSize >> 5) + 1;
		const sampleMarksIntsCount = (samplesCount >> 5) + 1;
		const returnBuffer = new ArrayBuffer(4 * samplesCount + 4 * chunksCount + 8 * storageSize + 8 * blocksCount + 16 * zoomToGroupSize.length + 4 * storageMarksIntsCount + 4 * sampleMarksIntsCount);
		const sampleToChunkEnds = new Uint32Array(returnBuffer, 0, samplesCount);
		const chunksToStorage = new Uint32Array(returnBuffer, 4 * samplesCount, chunksCount);
		const storage = new Uint32Array(returnBuffer, 4 * samplesCount + 4 * chunksCount, storageSize);
		const storageSizes = new Uint32Array(returnBuffer, 4 * samplesCount + 4 * chunksCount + 4 * storageSize, storageSize);
		const counts = new Int32Array(returnBuffer, 4 * samplesCount + 4 * chunksCount + 8 * storageSize, blocksCount);
		const foundCounts = new Int32Array(returnBuffer, 4 * samplesCount + 4 * chunksCount + 8 * storageSize + 4 * blocksCount, blocksCount);
		const maxCounts = new Uint32Array(returnBuffer, 4 * samplesCount + 4 * chunksCount + 8 * storageSize + 8 * blocksCount, zoomToGroupSize.length);
		const searchMaxCounts = new Uint32Array(returnBuffer, 4 * samplesCount + 4 * chunksCount + 8 * storageSize + 8 * blocksCount + 4 * zoomToGroupSize.length, zoomToGroupSize.length);
		const minCounts = new Uint32Array(returnBuffer, 4 * samplesCount + 4 * chunksCount + 8 * storageSize + 8 * blocksCount + 8 * zoomToGroupSize.length, zoomToGroupSize.length);
		const searchMinCounts = new Uint32Array(returnBuffer, 4 * samplesCount + 4 * chunksCount + 8 * storageSize + 8 * blocksCount + 12 * zoomToGroupSize.length, zoomToGroupSize.length);
		const marks = new Uint32Array(returnBuffer, 4 * samplesCount + 4 * chunksCount + 8 * storageSize + 8 * blocksCount + 16 * zoomToGroupSize.length, storageMarksIntsCount);
		const sampleMarks = new Uint32Array(returnBuffer, 4 * samplesCount + 4 * chunksCount + 8 * storageSize + 8 * blocksCount + 16 * zoomToGroupSize.length + 4 * storageMarksIntsCount, sampleMarksIntsCount);

		const huffmanTableSize = data.nextVarInt();
		const huffmanMaxBits = data.nextVarInt();

		const huffmanValues = new Uint32Array(huffmanTableSize);
		const huffmanCounts = new Uint32Array(huffmanMaxBits + 1);
		for (let i = 0; i < huffmanTableSize; i++) {
			huffmanValues[i] = data.nextVarInt();
			huffmanCounts[data.nextVarInt()]++;
		}

		if (huffmanMaxBits === 0) {
			counts.fill(huffmanValues[0]);
		} else {
			let firstHuffmanCodeForCount = 0;
			let currentHuffmanCode = 0;
			let currentCountPos = 1;
			let valuesPos = 0;

			let block = 0;
			a:while (true) {
				let bits = data.nextBase123();

				for (let i = 0; i < 27; i++) {      // 27 bits per symbol
					currentHuffmanCode |= bits & 1;
					bits >>>= 1;
					let count = huffmanCounts[currentCountPos];

					let nextHuffmanCodeForCount = firstHuffmanCodeForCount + count;
					if (nextHuffmanCodeForCount > currentHuffmanCode) {
						counts[block] = huffmanValues[valuesPos + currentHuffmanCode - firstHuffmanCodeForCount];
						if (++block >= blocksCount) {
							break a;
						}
						firstHuffmanCodeForCount = 0;
						currentHuffmanCode = 0;
						currentCountPos = 1;
						valuesPos = 0;
					} else {
						firstHuffmanCodeForCount = nextHuffmanCodeForCount << 1;
						currentHuffmanCode <<= 1;
						currentCountPos++;
						valuesPos += count;
					}
				}
			}
		}

		let synonymsCount = data.nextVarInt();
		const synonyms = new Uint32Array(synonymsCount);
		for (let i = 0; i < synonymsCount; i++) {
			synonyms[i] = data.nextVarInt();
		}

		let totalCount = 0;
		for (let c = 0; c < counts.length; c++) {
			totalCount += counts[c];
			counts[c] = totalCount;
		}

		calculateMinMax(counts, minCounts, maxCounts);

		for (let recordId = 1; recordId < lz78RecordsCount; recordId++) {
			const prevChunkId = data.nextVarInt();
			const addMethodId = data.nextVarInt();

			const lzPrevRecordId = (prevChunkId < synonymsCount ? synonyms[prevChunkId] : prevChunkId) - synonymsCount;

			// 0 bit for starts, 1 bit for leafs
			const prevFlags = lz78RootMethods[lzPrevRecordId];
			lz78RootMethods[lzPrevRecordId] = prevFlags & 1;   // not a leaf anymore
			lz78RootMethods[recordId] = lzPrevRecordId === 0
				? (starts.has(addMethodId) ? 3 : 2)
				: (prevFlags | 2);  // leaf for now

			lz78CurrentMethods[recordId] = addMethodId;
			lz78Parents[recordId] = lzPrevRecordId;
			lz78Sizes[recordId] = lz78Sizes[lzPrevRecordId] + 1;
		}

		let pos = 0;
		for (let rid = 1; rid < lz78RecordsCount; rid++) {
			const flags = lz78RootMethods[rid];
			if (flags & 2) {    // leaf
				const storagePos = lz78Refs[rid];
				if (storagePos === 0) {
					let recordId = rid;
					let size = lz78Sizes[recordId];
					do {
						storageSizes[pos] = size--;
						storage[pos] = lz78CurrentMethods[recordId];
						pos++;
						lz78Refs[recordId] = pos;
						recordId = lz78Parents[recordId];
					} while (recordId !== 0 && lz78Refs[recordId] === 0);

					while (recordId !== 0) {
						storageSizes[pos] = size--;
						storage[pos] = lz78CurrentMethods[recordId];
						pos++;
						recordId = lz78Parents[recordId];
					}
				}
			}
		}

		synonymsCount = data.nextVarInt();
		for (let i = 0; i < synonymsCount; i++) {
			synonyms[i] = data.nextVarInt();
		}

		let sample = 0;
		for (let chunk = 0; chunk < chunksCount; chunk++) {
			const chunkId = data.nextVarInt();
			let recordId = (chunkId < synonymsCount ? synonyms[chunkId] : chunkId) - synonymsCount;
			const flags = lz78RootMethods[recordId];
			chunksToStorage[chunk] = recordId;
			if (flags & 1) {    // start of the next sample
				if (sample !== 0) {
					sampleToChunkEnds[sample - 1] = chunk;
				}
				sample++;
			}
		}
		if (pos > storage.length) {
			throw "storage is too low";
		}
		sampleToChunkEnds[sample - 1] = chunksCount;

		for (let chunk = 0; chunk < chunksCount; chunk++) {
			const recordId = chunksToStorage[chunk];
			if (lz78Refs[recordId] === 0) {
				throw recordId + " has no storagePos";
			}
			chunksToStorage[chunk] = lz78Refs[recordId] - 1;
		}

		return {
			sampleToChunkEnds: sampleToChunkEnds,
			chunksToStorage: chunksToStorage,
			storage: storage,
			storageSizes: storageSizes,
			counts: counts,
			foundCounts: foundCounts,
			maxCounts: maxCounts,
			searchMaxCounts: searchMaxCounts,
			minCounts: minCounts,
			searchMinCounts: searchMinCounts,
			marks: marks,
			sampleMarks: sampleMarks,
		};
	}

	class HeatmapCollection extends DataBuffer {

		minimalTimeSquare = 20; // hardcoded for now
		squaresBetweenMarks = 20; // hardcoded forever)

		zoom;
		timeSquareScale;
		timeSquareRowsCount;

		blocksData;

		constructor(encodedData) {
			super(encodedData);

			this.blocksData = decodeExecutions(this);
			this.data = undefined;
		}

		currentTimeSquareMs() {
			return this.minimalTimeSquare * this.timeSquareScale;
		}

		startBlock() {
			const timeSquareMs = this.currentTimeSquareMs();
			const timeBlockMs = timeSquareMs * this.timeSquareRowsCount * this.squaresBetweenMarks;
			return Math.floor(startMs % timeBlockMs / timeSquareMs);
		}

		count() {
			const timeSquaresCountInMarkBlock = this.timeSquareRowsCount * this.squaresBetweenMarks;
			const scaledTimeSquaresCount = Math.ceil(this.blocksData.counts.length / this.timeSquareScale) + this.startBlock();
			return Math.ceil(scaledTimeSquaresCount / timeSquaresCountInMarkBlock) * timeSquaresCountInMarkBlock;
		}

		setZoom(z) {
			this.zoom = z;
			this.timeSquareScale = zoomToGroupSize[z];
			this.timeSquareRowsCount = zoomToHeight[z];
		}

		max(search) {
			return search ? this.blocksData.searchMaxCounts[this.zoom] : this.blocksData.maxCounts[this.zoom];
		}

		min(search) {
			return search ? this.blocksData.searchMinCounts[this.zoom] : this.blocksData.minCounts[this.zoom];
		}
	}

	function claimHtml(id) {
		let e = document.getElementById(id);
		let r = e.innerHTML;
		e.remove();
		return r;
	}

	function methodName(className, methodName, bci, line, type) {
		const locationSuffix = line === 0 ? (bci === 0 ? "" : ("@" + bci)) : (":" + line);

		if (methodName === '') {
			return className + locationSuffix;
		}
		if (className === '') {
			return methodName + locationSuffix;
		}
		if (type >= 3 && type <= 5) {
			return methodName + locationSuffix;
		}

		return className + "." + methodName + locationSuffix;
	}

	function readMethods(data) {
		data.nextInt6();
		const count = data.nextVarInt();
		const names = [];
		const colors = [];
		const bcis = new Array(count + 1);

		names.push(methodName("all", "", 0, 0, 3));
		colors.push(getColorStable(palette[3], 0));

		for (let i = 0; i < count; i++) {
			const className = data.nextVarInt();
			const name = data.nextVarInt();
			const bci = data.nextInt18();
			const line = data.nextInt18();
			const type = data.nextInt6();

			const noline = bci === 0xffff && line === 0xffff;

			names.push(methodName(cpool[className], cpool[name], noline ? 0 : bci, noline ? 0 : line, type));
			colors.push(getColorStable(palette[type], i + 1));
			bcis[i + 1] = noline ? "" : ", bci: " + bci;
		}

		return {n: names, c: colors, b: bcis};
	}

	let sq = 5;
	let sqPx = sq;
	let sqScale = 1;
	const canvasScrollPadding = 200;
	const taskMaxTimeMs = 8;
	let canvasTimeHeight = 12;
	let canvasTimeHeightPx = 12;
	let startMs = 1750696094588;

	const zoomToGroupSize = [
		1,              // 20 ms
		50,             // 1 s
		50 * 5,         // 5 s
	];
	const zoomToHeight = [
		50,
		60,
		60,
	];
	const zoomToText = [
		' 1 sec : 20 ms ',
		' 1 min : 1 sec ',
		' 5 min : 5 sec ',
		' 1 hr  : 1 min '
	];

	const currentHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
	let cpool = ["","all","java/lang/Thread","run","runWith","org/apache/tomcat/util/threads/TaskThread$WrappingRunnable","org/apache/tomcat/util/threads/ThreadPoolExecutor$Worker","org/apache/tomcat/util/threads/ThreadPoolExecutor","runWorker","org/apache/tomcat/util/net/SocketProcessorBase","org/apache/tomcat/util/net/NioEndpoint$SocketProcessor","doRun","org/apache/coyote/AbstractProtocol$ConnectionHandler","process","org/apache/coyote/AbstractProcessorLight","org/apache/coyote/http11/Http11Processor","service","org/apache/catalina/connector/CoyoteAdapter","org/apache/catalina/core/StandardEngineValve","invoke","org/apache/catalina/valves/ErrorReportValve","org/apache/catalina/core/StandardHostValve","org/apache/catalina/authenticator/AuthenticatorBase","org/apache/catalina/core/StandardContextValve","org/apache/catalina/core/StandardWrapperValve","org/apache/catalina/core/ApplicationFilterFactory","createFilterChain","matchDispatcher","org/apache/tomcat/util/net/NioEndpoint$Poller","processKey","org/apache/tomcat/util/net/AbstractEndpoint","processSocket","execute","executeInternal","org/apache/tomcat/util/threads/TaskQueue","offer","java/util/concurrent/LinkedBlockingQueue","signalNotEmpty","java/util/concurrent/locks/ReentrantLock","unlock","java/util/concurrent/locks/AbstractQueuedSynchronizer","release","signalNext","java/util/concurrent/locks/LockSupport","unpark","jdk/internal/misc/Unsafe","Unsafe_Unpark","pthread_cond_signal","org/apache/catalina/core/ApplicationFilterChain","doFilter","internalDoFilter","org/springframework/web/filter/OncePerRequestFilter","org/springframework/web/filter/CharacterEncodingFilter","doFilterInternal","org/springframework/web/filter/ServerHttpObservationFilter","org/springframework/web/filter/FormContentFilter","org/springframework/web/filter/RequestContextFilter","org/apache/tomcat/websocket/server/WsFilter","jakarta/servlet/http/HttpServlet","org/springframework/web/servlet/FrameworkServlet","doGet","processRequest","org/springframework/web/servlet/DispatcherServlet","doService","doDispatch","org/springframework/web/servlet/mvc/method/AbstractHandlerMethodAdapter","handle","org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter","handleInternal","invokeHandlerMethod","org/springframework/web/servlet/mvc/method/annotation/ServletInvocableHandlerMethod","invokeAndHandle","org/springframework/web/method/support/HandlerMethodReturnValueHandlerComposite","handleReturnValue","org/springframework/web/servlet/mvc/method/annotation/HttpEntityMethodProcessor","org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor","writeWithMessageConverters","org/springframework/web/servlet/mvc/method/annotation/RequestResponseBodyAdviceChain","beforeBodyWrite","processBody","org/springframework/web/servlet/mvc/method/annotation/JsonViewResponseBodyAdvice","supports","org/springframework/web/servlet/mvc/method/annotation/AbstractMappingJacksonResponseBodyAdvice","java/lang/Class","isAssignableFrom","jni_IsAssignableFrom","getHandler","org/springframework/web/servlet/handler/AbstractHandlerMapping","getHandlerExecutionChain","org/springframework/web/servlet/HandlerExecutionChain","addInterceptor","org/springframework/http/converter/AbstractGenericHttpMessageConverter","write","org/springframework/http/converter/json/AbstractJackson2HttpMessageConverter","writeInternal","com/fasterxml/jackson/databind/ObjectWriter","writeValue","com/fasterxml/jackson/databind/ObjectWriter$Prefetch","serialize","com/fasterxml/jackson/databind/ser/DefaultSerializerProvider","serializeValue","_serialize","com/fasterxml/jackson/databind/ser/BeanSerializer","com/fasterxml/jackson/databind/ser/std/BeanSerializerBase","serializeFields","com/fasterxml/jackson/databind/ser/BeanPropertyWriter","serializeAsField","com/fasterxml/jackson/databind/ser/impl/IndexedListSerializer","serializeContents","serializeContentsUsing","com/fasterxml/jackson/databind/ser/std/StringSerializer","org/springframework/web/method/support/InvocableHandlerMethod","invokeForRequest","doInvoke","java/lang/reflect/Method","jdk/internal/reflect/DirectMethodHandleAccessor","invokeImpl","java/lang/invoke/Invokers$Holder","invokeExact_MT","java/lang/invoke/LambdaForm$MH.0x00003ff00164dc00","java/lang/invoke/LambdaForm$DMH.0x00003ff0010e9400","invokeVirtual","info/jab/ms/controller/FilmController","getFilms","info/jab/ms/controller/FilmDTO","fromEntities","java/util/stream/ReferencePipeline","toList","toArray","java/util/stream/AbstractPipeline","evaluateToArrayNode","evaluate","wrapAndCopyInto","copyInto","java/util/ArrayList$ArrayListSpliterator","forEachRemaining","java/util/stream/ReferencePipeline$3$1","accept","itable stub","info/jab/ms/service/FilmService$$SpringCGLIB$$0","findFilmEntitiesByStartingLetter","org/springframework/aop/framework/CglibAopProxy$DynamicAdvisedInterceptor","intercept","org/springframework/aop/framework/ReflectiveMethodInvocation","proceed","org/springframework/transaction/interceptor/TransactionInterceptor","org/springframework/transaction/interceptor/TransactionAspectSupport","invokeWithinTransaction","org/springframework/transaction/interceptor/TransactionInterceptor$$Lambda.0x00003ff00162c088","proceedWithInvocation","invokeJoinpoint","org/springframework/aop/support/AopUtils","invokeJoinpointUsingReflection","java/lang/invoke/LambdaForm$MH.0x00003ff00164c800","info/jab/ms/service/FilmService","jdk/proxy4/$Proxy116","findByTitleStartingWith","org/springframework/aop/framework/JdkDynamicAopProxy","org/springframework/dao/support/PersistenceExceptionTranslationInterceptor","java/lang/invoke/LambdaForm$MH.0x00003ff00164cc00","java/lang/invoke/LambdaForm$DMH.0x00003ff001034c00","invokeInterface","org/springframework/data/projection/DefaultMethodInvokingMethodInterceptor","org/springframework/data/repository/core/support/QueryExecutorMethodInterceptor","org/springframework/data/repository/core/support/RepositoryMethodInvoker","org/springframework/data/repository/core/support/RepositoryMethodInvoker$RepositoryQueryMethodInvoker$$Lambda.0x00003ff00162e0d8","org/springframework/data/jdbc/repository/query/StringBasedJdbcQuery","org/springframework/data/jdbc/repository/query/AbstractJdbcQuery$$Lambda.0x00003ff00162fc60","org/springframework/data/jdbc/repository/query/AbstractJdbcQuery","lambda$createSingleReadingQueryExecution$3","org/springframework/jdbc/core/namedparam/NamedParameterJdbcTemplate","query","org/springframework/jdbc/core/JdbcTemplate","org/springframework/jdbc/core/JdbcTemplate$1","doInPreparedStatement","org/springframework/jdbc/core/RowMapperResultSetExtractor","extractData","org/springframework/data/jdbc/repository/support/JdbcQueryLookupStrategy$PostProcessingRowMapper","mapRow","org/springframework/data/jdbc/core/convert/EntityRowMapper","org/springframework/data/jdbc/core/convert/MappingJdbcConverter","readAndResolve","org/springframework/data/relational/core/conversion/MappingRelationalConverter","readAggregate","read","org/springframework/data/mapping/model/ClassGeneratingEntityInstantiator","createInstance","org/springframework/data/mapping/model/ClassGeneratingEntityInstantiator$EntityInstantiatorAdapter","extractInvocationArguments","org/springframework/data/mapping/model/ValueExpressionParameterValueProvider","getParameterValue","org/springframework/data/relational/core/conversion/MappingRelationalConverter$ConvertingParameterValueProvider","org/springframework/data/relational/core/conversion/MappingRelationalConverter$$Lambda.0x00003ff00163c490","apply","org/springframework/data/mapping/model/PersistentEntityParameterValueProvider","org/springframework/data/relational/core/conversion/MappingRelationalConverter$2","getPropertyValue","org/springframework/data/jdbc/core/convert/MappingJdbcConverter$ResolvingRelationalPropertyValueProvider","org/springframework/data/convert/CustomConversions","isSimpleType","org/springframework/data/mapping/model/SimpleTypeHolder","java/util/WeakHashMap","get","hash","java/lang/Object","hashCode","JVM_IHashCode","org/apache/commons/logging/LogAdapter$Slf4jLocationAwareLog","debug","ch/qos/logback/classic/Logger","log","filterAndLog_0_Or3Plus","buildLoggingEventAndAppend","callAppenders","appendLoopOnAppenders","ch/qos/logback/core/spi/AppenderAttachableImpl","ch/qos/logback/core/UnsynchronizedAppenderBase","doAppend","ch/qos/logback/core/OutputStreamAppender","append","subAppend","writeOut","writeBytes","writeByteArrayToOutputStreamWithPossibleFlush","ch/qos/logback/core/joran/spi/ConsoleTarget$1","java/io/PrintStream","java/io/BufferedOutputStream","java/lang/System$Out","java/io/FileOutputStream","io/micrometer/observation/SimpleObservation","stop","io/micrometer/observation/Observation$Context","addLowCardinalityKeyValues","addLowCardinalityKeyValue","selectHandler","org/springframework/web/servlet/mvc/method/annotation/ResponseBodyEmitterReturnValueHandler","supportsReturnType","org/springframework/core/ResolvableType","getGeneric","getGenerics","forType","<init>","com/zaxxer/hikari/pool/HikariProxyPreparedStatement","executeQuery","com/zaxxer/hikari/pool/ProxyPreparedStatement","org/postgresql/jdbc/PgPreparedStatement","executeWithFlags","org/postgresql/jdbc/PgStatement","org/postgresql/core/v3/QueryExecutorImpl","org/postgresql/core/v3/SimpleParameterList","convertFunctionOutParameters","direction","org/springframework/data/relational/core/mapping/RelationalMappingContext","getAggregatePath","java/util/concurrent/ConcurrentHashMap","org/springframework/data/relational/core/mapping/RelationalMappingContext$AggregatePathCacheKey","equals","java/lang/invoke/LambdaForm$MH.0x00003ff0013aac00","linkToTargetMethod","java/lang/invoke/LambdaForm$MH.0x00003ff0013aa400","guard","java/lang/invoke/DelegatingMethodHandle$Holder","delegate","java/lang/invoke/LambdaForm$MH.0x00003ff0013aa800","java/lang/invoke/LambdaForm$MH.0x00003ff0013a9000","getTask","take","java/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject","await","java/util/concurrent/ForkJoinPool","managedBlock","unmanagedBlock","java/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionNode","block","park","pthread_jit_write_protect_np","org/springframework/context/support/AbstractApplicationContext","publishEvent","forInstance","org/springframework/data/relational/core/mapping/event/RelationalEvent","getResolvableType","forClassWithGenerics","org/springframework/util/ConcurrentReferenceHashMap","getReference","org/springframework/util/ConcurrentReferenceHashMap$Segment","findInChain","org/springframework/util/ObjectUtils","nullSafeEquals","equalsType","org/springframework/core/ResolvableType$SyntheticParameterizedType","commitTransactionAfterReturning","org/springframework/transaction/support/AbstractPlatformTransactionManager","commit","processCommit","triggerBeforeCompletion","org/springframework/transaction/support/TransactionSynchronizationUtils","org/springframework/transaction/support/TransactionSynchronizationManager","getSynchronizations","java/lang/ThreadLocal","java/lang/ThreadLocal$ThreadLocalMap","getEntry","java/lang/ref/Reference","refersTo","refersToImpl","refersTo0","JVM_ReferenceRefersTo","getMethodArgumentValues","org/springframework/web/method/support/HandlerMethodArgumentResolverComposite","resolveArgument","org/springframework/web/method/annotation/AbstractNamedValueMethodArgumentResolver","convertIfNecessary","org/springframework/validation/DataBinder","org/springframework/beans/TypeConverterSupport","org/springframework/beans/TypeConverterDelegate","org/springframework/core/convert/support/GenericConversionService","canConvert","getConverter","org/springframework/core/convert/support/GenericConversionService$ConverterCacheKey","org/springframework/core/convert/TypeDescriptor","getTypeParameters","sun/reflect/generics/repository/GenericDeclRepository","clone","JVM_Clone","addContentDispositionHeader","org/springframework/http/server/ServletServerHttpResponse$ServletResponseHttpHeaders","containsKey","java/util/concurrent/ThreadPoolExecutor$Worker","java/util/concurrent/ThreadPoolExecutor","java/util/concurrent/ScheduledThreadPoolExecutor$DelayedWorkQueue","awaitNanos","parkNanos","Unsafe_Park","Parker::park","__psynch_cvwait","org/springframework/web/servlet/mvc/method/RequestMappingInfoHandlerMapping","getHandlerInternal","org/springframework/web/servlet/handler/AbstractHandlerMethodMapping","lookupHandlerMethod","addMatchingMappings","getMatchingMapping","org/springframework/web/servlet/mvc/method/RequestMappingInfo","getMatchingCondition","org/springframework/web/servlet/mvc/condition/RequestMethodsRequestCondition","matchRequestMethod","java/util/HashSet","contains","java/util/HashMap","getNode","org/springframework/data/jdbc/core/convert/MappingJdbcConverter$ResolvingConversionContext","forProperty","org/springframework/data/relational/core/mapping/DefaultAggregatePath","org/springframework/util/ConcurrentLruCache","processRead","org/springframework/util/ConcurrentLruCache$ReadOperations","recordRead","java/util/concurrent/atomic/AtomicReferenceArray","lazySet","java/lang/invoke/VarHandleGuards","guard_LIL_V","java/lang/invoke/VarHandleReferences$Array","setRelease","runtimeTypeCheck","reflectiveTypeCheck","getComponentType","org/springframework/web/servlet/handler/AbstractHandlerMethodMapping$MappingRegistry","releaseReadLock","java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock","releaseShared","drainOperations","drain","drainReadBuffer","org/springframework/util/ConcurrentLruCache$EvictionQueue","moveToBack","unlink","hasCustomReadTarget","getCustomReadTarget","org/springframework/data/convert/CustomConversions$ConversionTargetsCache","computeIfAbsent","org/springframework/data/convert/CustomConversions$TargetTypes","getProducibleMediaTypes","org/springframework/http/converter/ResourceRegionHttpMessageConverter","canWrite","org/springframework/web/servlet/mvc/condition/ProducesRequestCondition","getAcceptedMediaTypes","org/springframework/web/accept/ContentNegotiationManager","resolveMediaTypes","org/springframework/web/accept/HeaderContentNegotiationStrategy","org/springframework/http/MediaType","parseMediaTypes","parseMediaType","org/springframework/util/MimeTypeUtils","parseMimeType","sun/nio/ch/SelectorImpl","select","lockAndDoSelect","sun/nio/ch/KQueueSelectorImpl","doSelect","processDeregisterQueue","java/nio/channels/spi/AbstractSelector","deregister","java/nio/channels/spi/AbstractSelectableChannel","removeKey","isReleasable","org/apache/catalina/core/StandardContext","findFilterConfig","Runtime1::monitorenter","SharedRuntime::monitor_enter_helper","LightweightSynchronizer::enter","LightweightSynchronizer::inflate_and_enter","ObjectMonitor::enter","ObjectMonitor::enter_with_contention_mark","ObjectMonitor::EnterI","PlatformEvent::park","isArray","JVM_IsArrayClass","initContextHolders","org/apache/catalina/connector/RequestFacade","getLocale","org/apache/catalina/connector/Request","parseLocales","org/apache/tomcat/util/http/ValuesEnumerator","nextElement","readValue","getPotentiallyConvertedSimpleRead","org/springframework/data/relational/core/conversion/MappingRelationalConverter$DocumentValueProvider","getValue","convert","org/springframework/data/relational/core/conversion/MappingRelationalConverter$ConversionContext","org/springframework/data/relational/core/conversion/MappingRelationalConverter$DefaultConversionContext","org/springframework/data/relational/core/conversion/MappingRelationalConverter$$Lambda.0x00003ff0016372d0","org/apache/coyote/http11/Http11InputBuffer","parseRequestLine","fill","org/apache/tomcat/util/net/NioEndpoint$NioSocketWrapper","fillReadBuffer","java/io/EOFException","java/io/IOException","java/lang/Exception","java/lang/Throwable","fillInStackTrace","Java_java_lang_Throwable_fillInStackTrace","JVM_FillInStackTrace","java_lang_Throwable::fill_in_stack_trace","getGenericInfo","org/springframework/http/converter/FormHttpMessageConverter","setMethodValidator","org/springframework/web/method/annotation/HandlerMethodValidator","determineValidationGroups","org/springframework/validation/beanvalidation/MethodValidationAdapter","org/springframework/core/annotation/AnnotationUtils","findAnnotation","org/springframework/core/annotation/TypeMappedAnnotations","scan","org/springframework/core/annotation/AnnotationsScanner","processMethod","processMethodHierarchy","processMethodAnnotations","org/springframework/core/BridgeMethodResolver","findBridgedMethod","isResourceNotModified","org/springframework/http/HttpHeaders","remove","org/springframework/util/MultiValueMapAdapter","org/springframework/util/LinkedCaseInsensitiveMap","removeCaseInsensitiveKey","removeNode","org/springframework/data/mapping/callback/DefaultEntityCallbacks","callback","org/springframework/data/mapping/callback/EntityCallbackDiscoverer","getEntityCallbacks","org/springframework/data/mapping/callback/EntityCallbackDiscoverer$CallbackCacheKey","java/util/Objects","java/util/Arrays","jdk/internal/util/ArraysSupport","calculateHashCode","nullSafeHashCode","handleResolvedValue","determineTransactionManager","org/springframework/beans/factory/annotation/BeanFactoryAnnotationUtils","getQualifierValue","getAnnotation","processClass","processClassInheritedAnnotations","processElement","org/springframework/core/annotation/TypeMappedAnnotations$MergedAnnotationFinder","doWithAnnotations","org/springframework/core/annotation/AnnotationFilter","matches","jdk/proxy2/$Proxy72","annotationType","matchesKey","java/util/AbstractCollection","addAll","add","put","putVal","org/springframework/jdbc/datasource/DataSourceTransactionManager","doCommit","com/zaxxer/hikari/pool/HikariProxyConnection","com/zaxxer/hikari/pool/ProxyConnection","org/postgresql/jdbc/PgConnection","executeTransactionCommand","sendSync","org/postgresql/core/PGStream","flush","org/postgresql/util/internal/PgBufferedOutputStream","flushBuffer","java/net/Socket$SocketOutputStream","implWrite","sun/nio/ch/NioSocketImpl$2","sun/nio/ch/NioSocketImpl","tryWrite","sun/nio/ch/SocketDispatcher","write0","JavaFrameAnchor::make_walkable","processResults","receiveChar","org/postgresql/core/VisibleBufferedInputStream","ensureBytes","readMore","java/net/Socket$SocketInputStream","implRead","sun/nio/ch/NioSocketImpl$1","tryRead","read0","ch/qos/logback/classic/LoggerContext","getTurboFilterChainDecision_0_3OrMore","ch/qos/logback/classic/spi/TurboFilterList","getTurboFilterChainDecision","io/micrometer/core/instrument/binder/logging/MetricsTurboFilter","decide","getEntryAfterMiss","ch/qos/logback/core/encoder/LayoutWrappingEncoder","encode","ch/qos/logback/classic/PatternLayout","doLayout","ch/qos/logback/core/pattern/PatternLayoutBase","writeLoopOnConverters","ch/qos/logback/core/pattern/FormattingConverter","ch/qos/logback/core/pattern/CompositeConverter","org/springframework/boot/logging/logback/ColorConverter","transform","org/apache/tomcat/util/net/SocketWrapperBase","close","doClose","org/springframework/web/context/request/RequestContextHolder","setRequestAttributes","set","cleanSomeSlots","convertToBytes","java/lang/String","getBytes","encodeUTF8","java/lang/StringCoding","hasNegatives","countPositives","org/springframework/jdbc/datasource/DataSourceUtils","doGetConnection","nextRequest","org/apache/coyote/Request","recycle","java/lang/Long","toHexString","toUnsignedString0","formatUnsignedLong0","com/fasterxml/jackson/core/json/UTF8JsonGenerator","java/io/FilterOutputStream","org/springframework/web/context/request/async/StandardServletAsyncWebRequest$LifecycleServletOutputStream","org/apache/catalina/connector/CoyoteOutputStream","org/apache/catalina/connector/OutputBuffer","doFlush","org/apache/coyote/Response","action","org/apache/coyote/AbstractProcessor","prepareResponse","org/apache/tomcat/util/http/FastHttpDateFormat","getCurrentDate","org/apache/tomcat/util/http/ConcurrentDateFormat","format","java/util/concurrent/ConcurrentLinkedQueue","org/springframework/util/StringUtils","getFilenameExtension","lastIndexOf","getConversionContext","java/lang/invoke/DirectMethodHandle$Holder","newInvokeSpecial","java/lang/invoke/DirectMethodHandle","allocateInstance","Unsafe_AllocateInstance","org/springframework/data/util/ClassTypeInformation","org/springframework/data/util/TypeDiscoverer","java/lang/invoke/LambdaForm$MH.0x00003ff0010e5800","java/lang/invoke/LambdaForm$MH.0x00003ff0010e5400","java/lang/invoke/LambdaForm$MH.0x00003ff0010e4400","invokeStatic","ObjectSynchronizer::FastHashCode","read_stable_mark","createOrFetchObservation","start","notifyOnObservationStarted","io/micrometer/observation/ObservationHandler$FirstMatchingCompositeObservationHandler","onStart","io/micrometer/core/instrument/observation/DefaultMeterObservationHandler","io/micrometer/core/instrument/LongTaskTimer$Builder","tags","io/micrometer/core/instrument/Tags","and","of","java/util/ArrayList","copyOf","org/springframework/boot/devtools/filewatch/FileSystemWatcher$Watcher","getCurrentSnapshots","org/springframework/boot/devtools/filewatch/DirectorySnapshot","collectFiles","java/io/File","listFiles","java/io/UnixFileSystem","resolve","java/lang/StringBuilder","java/lang/AbstractStringBuilder","ensureCapacityInternal","isCallerSensitive","jdk/internal/reflect/Reflection","java/lang/reflect/AccessibleObject","isAnnotationPresent","java/lang/reflect/AnnotatedElement","org/springframework/context/event/SimpleApplicationEventMulticaster","multicastEvent","java/util/ArrayList$Itr","next","getParameterProvider","InstanceKlass::allocate_instance","getAttribute","receiveTupleV3","receive","jbyte_disjoint_arraycopy","java/nio/ByteBuffer","getArray","jdk/internal/misc/ScopedMemoryAccess","copyMemory","copyMemoryInternal","copyMemory0","Unsafe_CopyMemory0","os::javaTimeMillis","clock_gettime","gettimeofday","mach_absolute_time","org/springframework/data/mapping/context/MappingContext","getRequiredPersistentEntity","org/springframework/data/mapping/context/AbstractMappingContext","getPersistentEntity","os::current_thread_enable_wx","cleanupAfterCompletion","clear","setSocketWrapper","init","allocate","java/nio/HeapByteBuffer","org/apache/tomcat/util/net/NioChannel","setAppReadBufHandler","org/apache/tomcat/util/net/Acceptor","org/apache/tomcat/util/net/NioEndpoint","setSocketOptions","org/apache/tomcat/util/net/SocketProperties","setProperties","sun/nio/ch/SocketAdaptor","setSoLinger","setIntOption","sun/nio/ch/SocketChannelImpl","setOption","sun/nio/ch/Net","setSocketOption","setIntOption0","Java_sun_nio_ch_Net_setIntOption0","setsockopt","unknown_Java","thread_start","_pthread_start","thread_native_entry","Thread::call_run","WorkerThread::run","G1EvacuateRegionsBaseTask::work","G1EvacuateRegionsTask::evacuate_live_objects","G1ParEvacuateFollowersClosure::do_void","G1ParEvacuateFollowersClosure::offer_termination","TaskTerminator::offer_termination","swtch_pri","io/micrometer/observation/docs/ObservationDocumentation","observation","io/micrometer/observation/Observation","createNotStarted","org/springframework/http/server/observation/ServerRequestObservationConvention","supportsContext","getMatchingExpressions","org/springframework/web/servlet/mvc/condition/ProducesRequestCondition$ProduceMediaTypeExpression","match","matchMediaType","isCompatibleWith","org/springframework/util/MimeType","isWildcardSubtype","sun/nio/ch/Util","offerFirstTemporaryDirectBuffer","unwrapIfAlignedSlice","org/springframework/web/util/ServletRequestPathUtils","parseAndCache","org/springframework/web/util/ServletRequestPathUtils$ServletRequestPath","parse","org/springframework/http/server/RequestPath","org/springframework/http/server/DefaultRequestPath","extractPathWithinApplication","java/util/Collections$UnmodifiableCollection","size","java/util/Collections$EmptyList","isDirectory","hasBooleanAttributes","getBooleanAttributes0","stat64","org/springframework/web/bind/support/DefaultDataBinderFactory","createBinder","createBinderInternal","org/springframework/web/bind/support/ConfigurableWebBindingInitializer","initBinder","getTargetType","org/apache/coyote/http11/Http11OutputBuffer","org/apache/coyote/http11/filters/ChunkedOutputFilter","org/apache/coyote/http11/Http11OutputBuffer$SocketOutputBuffer","flushBlocking","doWrite","sun/nio/ch/IOUtil","writeFromNativeBuffer","parseHeaders","parseHeader","createTransactionIfNecessary","getTransaction","startTransaction","newTransactionStatus","org/springframework/transaction/interceptor/TransactionAspectSupport$1","getName","org/springframework/web/servlet/mvc/condition/ConsumesRequestCondition","isEmpty","org/springframework/web/cors/CorsUtils","isPreFlightRequest","org/springframework/http/HttpMethod","org/apache/catalina/connector/Response","finishResponse","end","org/springframework/web/context/request/ServletWebRequest","checkNotModified","validateIfNoneMatch","getHeaders","org/apache/tomcat/util/http/MimeHeaders","values","findNext","setSoTimeout","selectNow","sun/nio/ch/KQueue","poll","kevent","sleep","sleepNanos","sleepNanos0","JVM_SleepNanos","JavaThread::sleep_nanos","PlatformEvent::park_nanos","ZThread::~ZThread","tlv_get_addr","register","io/micrometer/core/instrument/MeterRegistry$More","longTaskTimer","io/micrometer/core/instrument/MeterRegistry","access$1100","io/micrometer/core/instrument/Meter$Id","getOrCreateMeter","getTemporaryDirectBuffer","jdk/internal/misc/CarrierThreadLocal","java/lang/System$1","getCarrierThreadLocal","org/springframework/core/annotation/AnnotatedMethod$AnnotatedMethodParameter","hasMethodAnnotation","org/springframework/core/annotation/AnnotatedMethod","org/springframework/core/annotation/AnnotatedElementUtils","hasAnnotation","isPresent","getBaseTypeMethods","getHash","writeHeaders","org/springframework/boot/devtools/filewatch/FileSnapshot","lastModified","getLastModifiedTime","getLastModifiedTime0","Java_java_io_UnixFileSystem_getLastModifiedTime0","jni_GetObjectField","java/util/concurrent/ScheduledThreadPoolExecutor$ScheduledFutureTask","java/util/concurrent/FutureTask","runAndReset","java/util/concurrent/Executors$RunnableAdapter","call","org/apache/coyote/AbstractProtocol$$Lambda.0x00003ff0015bf698","org/apache/coyote/AbstractProtocol","lambda$startAsyncTimeout$0","getMappingsByDirectPath","java/util/LinkedHashMap","com/fasterxml/jackson/databind/ser/std/MapSerializer","serializeWithoutTypeInfo","lock","acquireShared","java/util/concurrent/locks/ReentrantReadWriteLock$Sync","tryAcquireShared","getSupportedMediaTypes","JavaThread::thread_main_inner","MonitorDeflationThread::monitor_deflation_thread_entry","Monitor::wait_without_safepoint_check","PlatformMonitor::wait","org/springframework/data/mapping/model/AbstractPersistentProperty","getActualType","getActualTypeInformation","org/springframework/data/util/TypeInformation","getRequiredActualType","isNullableWrapper","org/springframework/data/util/NullableWrapperConverters","java/util/concurrent/ConcurrentMap","org/apache/catalina/core/ContainerBase","logAccess","java/util/concurrent/locks/ReentrantLock$Sync","tryRelease","getServletPathPrefix","getHttpServletMapping","org/apache/catalina/core/ApplicationMapping","receiveCommandStatus","receiveString","org/springframework/http/server/ServletServerHttpResponse","getBody","forEach","org/springframework/http/server/ServletServerHttpResponse$$Lambda.0x00003ff001647710","lambda$writeHeaders$0","jakarta/servlet/http/HttpServletResponseWrapper","addHeader","org/apache/catalina/connector/ResponseFacade","isCommitted","checkFacade","selectObjectMapper","java/util/HashMap$Node","getKey","vtable stub","java/lang/invoke/MethodHandleImpl","profileBoolean","java/lang/Math","addExact","getAcceptableMediaTypes","getHeaderValues","toStringArray","java/lang/reflect/Array","newInstance","newArray","JVM_NewArray","ArrayKlass::array_klass","VMThread::run","VMThread::inner_execute","VMThread::evaluate_operation","VM_Operation::evaluate","VM_G1CollectForAllocation::doit","G1CollectedHeap::do_collection_pause_at_safepoint","G1CollectedHeap::do_collection_pause_at_safepoint_helper","G1YoungCollector::collect","G1ParScanThreadStateSet::G1ParScanThreadStateSet","AllocateHeap","os::malloc","szone_malloc_should_clear","tiny_malloc_should_clear","tiny_malloc_from_free_list","openScope","io/micrometer/observation/SimpleObservation$SimpleScope","io/micrometer/observation/SimpleObservationRegistry","getCurrentObservationScope","valueOf","toString","Runtime1::exception_handler_for_pc","org/springframework/core/annotation/TypeMappedAnnotations$IsPresent","org/springframework/core/annotation/AnnotationTypeMappings","forAnnotationType","org/springframework/core/annotation/AnnotationTypeMappings$Cache","serverSocketAccept","sun/nio/ch/ServerSocketChannelImpl","java/nio/channels/spi/AbstractInterruptibleChannel","exists","io/micrometer/common/util/StringUtils","isNotBlank","isBlank","java/lang/Character","isWhitespace","getAccessLog","java/lang/invoke/MethodHandle","invokeBasic","sendQueryPreamble","sendOneQuery","sendSimpleQuery","org/postgresql/core/v3/SimpleQuery","org/postgresql/core/NativeQuery","java/util/HashMap$KeyIterator","java/util/HashMap$HashIterator","nextNode","org/springframework/http/server/observation/DefaultServerRequestObservationConvention","getLowCardinalityKeyValues","outcome","org/springframework/http/HttpStatusCode","org/springframework/http/HttpStatus","io/micrometer/core/instrument/distribution/DistributionStatisticConfig$Builder","validate","org/springframework/data/jdbc/core/convert/RowDocumentResultSetExtractor","toRowDocument","org/springframework/data/relational/domain/RowDocument","putIfAbsent","resize","org/springframework/context/event/AbstractApplicationEventMulticaster","getApplicationListeners","org/springframework/context/event/AbstractApplicationEventMulticaster$ListenerCacheKey","prepareRequest","parseHost","org/apache/tomcat/util/http/parser/Host","org/apache/tomcat/util/http/parser/HttpParser","readHostDomainName","validatePort","readLong","readDigits","triggerAfterCompletion","setAttribute","notifyAttributeAssigned","getApplicationEventListeners","java/util/concurrent/CopyOnWriteArrayList","CollectedHeap::array_allocate","org/springframework/jdbc/support/JdbcUtils","getResultSetValue","com/zaxxer/hikari/pool/HikariProxyResultSet","getObject","org/postgresql/jdbc/PgResultSet","internalGetObject","getSQLType","org/postgresql/util/internal/Nullness","castNonNull","_pthread_cond_wait","requireNonNullElse","requireNonNull","clearSynchronization","org/springframework/util/ClassUtils","getUserClass","isAssignableValue","isAssignable","publishRequestHandledEvent","getRemoteAddr","populateRemoteAddr","java/net/Inet6Address","getHostAddress","java/net/Inet6Address$Inet6AddressHolder","numericToTextFormat","java/lang/Integer","formatUnsignedInt","MemAllocator::allocate","_platform_bzero","java/lang/StringLatin1","putArray","copyMemoryChecks","checkPrimitivePointer","checkPrimitiveArray","oopDesc::metadata_field","checkReceiver","os::javaTimeNanos","writeStartObject","_verifyValueWrite","AttachListenerThread::thread_entry","load_agent","JvmtiAgentList::load_agent","JvmtiAgent::load","Agent_OnAttach","Profiler::run","Profiler::runInternal","Profiler::start","Profiler::startTimer","jvmti_RunAgentThread","JvmtiEnv::RunAgentThread","JavaThread::start_internal_daemon","java_lang_Thread::set_daemon","setInitialValue","org/springframework/web/method/annotation/ModelFactory","initModel","org/springframework/web/method/annotation/SessionAttributesHandler","retrieveAttributes","java/util/concurrent/ConcurrentHashMap$KeySetView","iterator","convertKey","toLowerCase","processClassHierarchy","getDeclaredAnnotations","restructureIfNecessary","org/springframework/util/ConcurrentReferenceHashMap$ReferenceManager","pollForPurge","java/lang/ref/ReferenceQueue","JvmtiAgentThread::start_function_wrapper","Profiler::timerLoop","WaitableMutex::waitUntil","appendChars","org/springframework/context/event/AbstractApplicationEventMulticaster$CachedListenerRetriever","forClass","forMethodParameter","org/springframework/core/SerializableTypeWrapper","forTypeProvider","sun/reflect/generics/reflectiveObjects/ParameterizedTypeImpl","org/springframework/data/repository/core/support/RepositoryInvocationMulticaster$DefaultRepositoryInvocationMulticaster","notifyListeners","org/springframework/boot/actuate/metrics/data/MetricsRepositoryMethodInvocationListener","afterInvocation","org/springframework/boot/actuate/metrics/AutoTimer","org/springframework/boot/actuate/metrics/data/MetricsRepositoryMethodInvocationListener$$Lambda.0x00003ff00163b6b0","lambda$afterInvocation$0","io/micrometer/core/instrument/Timer$Builder","org/springframework/web/servlet/mvc/method/annotation/ReactiveTypeHandler","isReactiveType","org/springframework/core/ReactiveAdapterRegistry","getAdapter","sendQuery","sendBind","sendInteger2","org/springframework/util/Assert","notNull","java/util/LinkedHashMap$LinkedHashIterator","hasNext","org/springframework/http/converter/xml/Jaxb2RootElementHttpMessageConverter","postParseRequest","org/apache/tomcat/util/buf/MessageBytes","duplicate","org/apache/tomcat/util/buf/ByteChunk","createTags","io/micrometer/common/KeyValues","java/util/concurrent/ConcurrentHashMap$ValuesView","java/util/concurrent/ConcurrentHashMap$Traverser","advance","_platform_memset","normalizedList","list","list0","Java_java_io_UnixFileSystem_list0","closedir","free_tiny","tiny_free_no_lock","tiny_free_list_add_ptr","org/apache/coyote/AbstractProtocol$RecycledProcessors","push","org/apache/tomcat/util/collections/SynchronizedStack","matchPreFlight","annotationsMatch","getAnnotations","org/springframework/core/convert/TypeDescriptor$AnnotatedElementAdapter","org/springframework/boot/actuate/metrics/data/DefaultRepositoryTagsProvider","repositoryTags","g1_post_barrier_slow","org/springframework/web/servlet/mvc/condition/AbstractMediaTypeExpression","matchParameters","org/springframework/util/ReflectionUtils","getDeclaredMethods","writeFieldName","com/fasterxml/jackson/core/io/SerializedString","appendQuotedUTF8","org/springframework/web/servlet/mvc/method/annotation/ModelAndViewMethodReturnValueHandler","org/springframework/core/annotation/AnnotatedMethod$ReturnValueMethodParameter","getParameterType","org/springframework/web/servlet/mvc/condition/PathPatternsRequestCondition","getMatchingPatterns","org/springframework/web/util/pattern/PathPattern","org/springframework/web/util/pattern/SeparatorPathElement","org/springframework/web/util/pattern/LiteralPathElement","processUpdateQueue","__psynch_cvsignal","JvmtiVMObjectAllocEventCollector::JvmtiVMObjectAllocEventCollector","ConcurrentGCThread::run","G1ConcurrentRefineThread::run_service","G1PrimaryConcurrentRefineThread::do_refinement_step","G1ConcurrentRefine::adjust_threads_periodically","G1Policy::estimate_used_young_bytes_locked","G1Allocator::used_in_alloc_regions","MutatorAllocRegion::used_in_alloc_regions","java/util/ArrayDeque","removeFirst","resetContextHolders","org/springframework/context/i18n/LocaleContextHolder","setLocaleContext","processEvents","clearInterrupt","com/fasterxml/jackson/databind/ObjectMapper","canSerialize","hasSerializerFor","com/fasterxml/jackson/databind/SerializerProvider","_findExplicitUntypedSerializer","isUnknownTypeSerializer","isEnabled","tryReleaseShared","clearImpl","java/lang/invoke/LambdaForm$MH.0x00003ff0010b8c00","org/apache/catalina/mapper/Mapper","map","internalMap","internalMapWrapper","potentiallyAppendIdentifier","org/springframework/data/jdbc/core/convert/Identifier","withPart","java/util/Collections","unmodifiableList","io/micrometer/core/instrument/internal/DefaultLongTaskTimer","java/util/concurrent/ConcurrentSkipListSet","java/util/concurrent/ConcurrentSkipListMap","doPut","addIndices","ServiceThread::service_thread_entry","__opendir2","__open_nocancel","sendHeader","toBytes","toCharArray","toChars","readdir","__getdirentries64","org/springframework/web/servlet/mvc/condition/AbstractRequestCondition","java/util/AbstractSet","startsWith","setValue","org/apache/coyote/http11/AbstractHttp11Protocol","useCompression","org/apache/coyote/CompressionConfig","java/io/StringReader","java/io/Reader","org/postgresql/jdbc/ResourceLock","org/springframework/transaction/support/DelegatingTransactionDefinition","getPropagationBehavior","org/springframework/transaction/support/DefaultTransactionDefinition","ch/qos/logback/classic/pattern/DateConverter","ch/qos/logback/core/util/CachingDateFormatter","java/time/format/DateTimeFormatter","formatTo","java/time/format/DateTimeFormatterBuilder$CompositePrinterParser","java/time/format/DateTimeFormatterBuilder$NanosPrinterParser","getChars","org/springframework/data/jdbc/core/convert/Identifier$SingleIdentifierValue","io/micrometer/core/instrument/binder/logging/LogbackMetrics","ignoreMetrics","io/micrometer/core/instrument/binder/logging/MetricsTurboFilter$$Lambda.0x00003ff0015babc8","lambda$decide$0","recordMetrics","io/micrometer/core/instrument/Counter","increment","io/micrometer/core/instrument/cumulative/CumulativeCounter","java/util/concurrent/atomic/DoubleAdder","finishAccept","localAddress","localPort","getsockname","java/net/InetSocketAddress","java/net/InetSocketAddress$InetSocketAddressHolder","mismatch","checkPointer","checkSize","org/apache/tomcat/util/http/Parameters","doBegin","com/zaxxer/hikari/HikariDataSource","getConnection","com/zaxxer/hikari/pool/HikariPool","com/zaxxer/hikari/pool/PoolBase$MetricsTrackerDelegate","recordBorrowStats","com/zaxxer/hikari/metrics/micrometer/MicrometerMetricsTracker","recordConnectionAcquiredNanos","io/micrometer/core/instrument/AbstractTimer","record","io/micrometer/core/instrument/cumulative/CumulativeTimer","recordNonNegative","io/micrometer/core/instrument/distribution/TimeWindowMax","purgeUnreferencedEntries","tryDisablePreempt","isAsyncStarted","initLookupPath","pathWithinApplication","ch/qos/logback/core/pattern/SpacePadder","leftPad","org/springframework/boot/logging/logback/EnclosedInSquareBracketsConverter","formatted","java/util/Formatter","flushByteBuffer","realWriteBytes","com/zaxxer/hikari/util/ConcurrentBag","borrow","com/zaxxer/hikari/util/FastList","org/postgresql/core/Encoding","arrayof_jbyte_disjoint_arraycopy","getClass","jni_GetObjectClass","getGenericType","JvmtiVMObjectAllocEventCollector::~JvmtiVMObjectAllocEventCollector","resolveEmbeddedValuesAndExpressions","org/springframework/beans/factory/support/AbstractBeanFactory","resolveEmbeddedValue","org/springframework/context/support/PropertySourcesPlaceholderConfigurer$$Lambda.0x00003ff0013b0960","resolveStringValue","org/springframework/context/support/PropertySourcesPlaceholderConfigurer","lambda$processProperties$0","org/springframework/core/env/AbstractPropertyResolver","resolveRequiredPlaceholders","doResolvePlaceholders","org/springframework/util/PropertyPlaceholderHelper","replacePlaceholders","parseStringValue","org/springframework/util/PlaceholderParser","withContext","newValueProvider","addActiveFilter","initSqlType","checkNativeAddress","triggerBeforeCommit","org/apache/tomcat/util/buf/CharChunk","VM_HandshakeAllThreads::doit","HandshakeState::try_process","Mutex::unlock","getInterfaces","indexOf","org/springframework/web/method/annotation/RequestParamMethodArgumentResolver","resolveName","getParameterValues","acquire","java/io/OutputStream","getHandlersFromConfig","readIntoNativeBuffer","org/springframework/web/context/request/async/WebAsyncManager","registerDeferredResultInterceptors","_flushBuffer","org/springframework/util/StreamUtils$NonClosingOutputStream","appendByteArray","transfer","limit","checkcast_arraycopy","isMap","org/springframework/data/util/Lazy","clear0","JVM_ReferenceClear","AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<397414ull, G1BarrierSet>, (AccessInternal::BarrierType)3, 397414ull>::oop_access_barrier","java_lang_ref_Reference::is_referent_field","C1 Runtime slow_subtype_check_blob","getType","unparkVirtualThread","getCallerClass","JVM_GetCallerClass","Klass::is_subclass_of","org/springframework/data/relational/core/mapping/event/AfterConvertEvent","org/springframework/data/relational/core/mapping/event/RelationalEventWithEntity","org/springframework/data/relational/core/mapping/event/AbstractRelationalEvent","org/springframework/context/ApplicationEvent","notifyOnObservationStopped","java/util/ArrayDeque$DescendingIterator","io/micrometer/observation/SimpleObservation$$Lambda.0x00003ff00164ba98","lambda$notifyOnObservationStopped$0","onStop","io/micrometer/core/instrument/internal/DefaultLongTaskTimer$SampleImpl","org/apache/tomcat/util/http/MimeHeaderField","info/jab/ms/controller/FilmController$$Lambda.0x00003ff0014f0840","test","lambda$static$0","java/util/regex/Pattern","compile","java/util/TreeSet","java/util/TreeMap$KeySet","prepareRequestProtocol","registerReadInterest","addEvent","wakeup","write1","implCloseChannel","implCloseSelectableChannel","implCloseNonBlockingMode","shutdown","InstanceKlass::check_valid_for_instantiation","java/lang/invoke/Invokers","checkCustomized","org/apache/catalina/webresources/StandardRoot","getResource","parametersAreEqual","endRequest","org/springframework/context/support/ApplicationObjectSupport","obtainApplicationContext","state","call_stub","newNode","org/springframework/core/$Proxy6","getActualTypeArguments","org/springframework/core/SerializableTypeWrapper$TypeProxyInvocationHandler","invokeMethod","arrayEquals","org/springframework/transaction/interceptor/AbstractFallbackTransactionAttributeSource","getTransactionAttribute","isObjectMethod","isEqualsMethod","com/zaxxer/hikari/pool/HikariPool$KeepaliveTask","com/zaxxer/hikari/pool/PoolBase","isConnectionDead","isValid","executeCachedSql","timedRead","java/util/EventObject","getSource","implAccept","Java_sun_nio_ch_Net_accept","jni_NewObject","jni_invoke_nonstatic","JNI_ArgumentPusherVaArg::push_arguments_on","JNI_ArgumentPusherVaArg::do_type","getColumnInfo","determineCompatibleMediaTypes","getMostSpecificMediaType","isLessSpecific","isMoreSpecific","getQualityValue","getParameter","registerMeterIfNecessary","java/text/DateFormat","java/text/SimpleDateFormat","java/text/StringBufFactory$StringBuilderImpl","newCapacity","newLength","prepareTransactionInfo","org/springframework/transaction/interceptor/TransactionAspectSupport$TransactionInfo","bindToThread","receiveInteger4","enableWait","ch/qos/logback/classic/pattern/ThreadConverter","__accept","writeString","_writeStringSegment","writeEndObject","MemAllocator::Allocation::notify_allocation","MemAllocator::Allocation::notify_allocation_jfr_sampler","getDataBinderFactory","Runtime1::new_instance","java/io/OutputStreamWriter","sun/nio/cs/StreamEncoder","ensureOpen","org/postgresql/core/PGStream$1","java/util/stream/StreamSupport","stream","dedup","events","keyFor","findKey","isAsyncReturnValue",];
	const methods = readMethods(new DataBuffer(claimHtml("methods")));
	cpool = null;

	let heatLastSample = -1;
	let heatActiveSample1 = -1;
	let heatActiveSample2 = -1;
	let heatDiffSample1 = -1;
	let heatDiffSample2 = -1;
	let highlightStart = -1;
	let highlightEnd = -1;

	const titleText = document.getElementById("title").textContent;
	document.getElementById("title").style.display = 'none';
	document.title = titleText;

	const heatCanvas = document.getElementById('heatmap-canvas');
	const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
	const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

	let heatC;
	let prevDx = -1000000000;

	const timeOptionsShort = {
		hour: '2-digit',
		minute: '2-digit',
		second: '2-digit',
		hourCycle: 'h23',
		fractionalSecondDigits: 2
	};

	const timeOptionsTiny = {
		hour: '2-digit',
		minute: '2-digit',
		second: '2-digit',
		hourCycle: 'h23'
	};

	function getCount(counts, i) {
		if (i < 0 || counts.length === 0) {
			return 0;
		}
		return counts[Math.min(i, counts.length - 1)];
	}

	let bgInterval = null;
	let bgTasks = [];
	let cooldownTime = 0;
	let nextTask = 0;

	function addTask(id, iteration, afterFrame) {
		if (!afterFrame) afterFrame = function () {};

		for (let t of bgTasks) {
			if (t.id === id) {
				t.f = iteration;
				t.a = afterFrame;
				return;
			}
		}

		bgTasks.push({id: id, f: iteration, a: afterFrame});
		if (bgTasks.length === 1) {
			bgInterval = setInterval(function () {
				let start = performance.now();
				if (start <= cooldownTime) {
					return;
				}
				let overflow = false;
				do {
					let task = bgTasks[nextTask];
					let runAgain;
					try {
						runAgain = task.f();
					} catch (e) {
						console.error(e);
						bgTasks.length = 0;
						clearInterval(bgInterval);
						nextTask = 0;
						return;
					}

					if (runAgain) {
						nextTask++;
					} else {
						bgTasks.splice(nextTask, 1);
						if (bgTasks.length === 0) {
							clearInterval(bgInterval);
							nextTask = 0;
							return;
						}
					}

					if (nextTask >= bgTasks.length) {
						nextTask = 0;
						overflow = true;
					}
				} while (performance.now() - start < taskMaxTimeMs);

				for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
					bgTasks[q].a();
				}
			})
		}
	}

	function sort(array, start, end, values, bit) {
		while (true) {
			switch (end - start) {
				case 0:
				case 1:
					return;
				case 2: {
					let a = array[start];
					let b = array[start + 1];
					if (values[a] < values[b]) {
						array[start] = b;
						array[start + 1] = a;
					}
					return;
				}
			}

			let left = start;
			let right = end;

			while (true) {
				while (left < right) {
					let v = values[array[left]];
					if ((v & bit) !== 0) {
						left++;
					} else {
						break;
					}
				}
				while (left < right) {
					let v = values[array[right - 1]];
					if ((v & bit) === 0) {
						right--;
					} else {
						break;
					}
				}

				if (left < right) {
					right--;
					let l = array[left];
					array[left] = array[right];
					array[right] = l;
					left++;
				} else {
					bit >>= 1;
					if (bit === 0) {
						return;
					}
					if (end - left > right - start) {
						if (right - start > 1) {
							sort(array, start, right, values, bit);
						}
						start = left;
					} else {
						if (end - left > 1) {
							sort(array, left, end, values, bit);
						}
						end = right;
					}
					break;
				}
			}
		}
	}

	function allocateHugeArray() {
		// Note: it is very random huge number that relies on malloc laziness
		// real pre-calculation is both non-performant and fragile
		return new Uint32Array(100 * 1024 * 1024);
	}

	function renderWrapper(from, to) {
		lastRenderFrom = from;
		lastRenderTo = to;
		renderFunc(from, to);
	}

	function renderWrapperDiff(from, to, baseFrom, baseTo) {
		lastRenderFrom = from;
		lastRenderTo = to;
		lastBaseRenderFrom = baseFrom;
		lastBaseRenderTo = baseTo;
		renderFuncDiff(from, to, baseFrom, baseTo);
	}

	function reselect() {
		if (heatDiffSample1 === -1) {
			renderFunc(lastRenderFrom, lastRenderTo);
		} else {
			renderFuncDiff(lastRenderFrom, lastRenderTo, lastBaseRenderFrom, lastBaseRenderTo);
		}
	}

	function selectMode(mode) {
		switch (mode) {
			case 'flame-mode-flame':
				renderFunc = renderTraces;
				renderFuncDiff = renderTracesDiff;
				break;
			case 'flame-mode-reversed':
				renderFunc = renderTracesReversed;
				renderFuncDiff = renderTracesReversedDiff;
				break;
			case 'flame-mode-methods':
				renderFunc = renderSelfDominators;
				renderFuncDiff = renderSelfDominatorsDiff;
				break;
		}
		for (let m of ['flame-mode-flame', 'flame-mode-reversed', 'flame-mode-methods']) {
			document.getElementById(m).classList.remove('toolbarSelected');
		}
		document.getElementById(mode).classList.add('toolbarSelected');
		reselect();
	}

	function diffColor(count, baseCount, minDiff, maxDiff) {
		if (baseCount === 0) {
			return "#ffdd33";
		}
		if (baseCount === count) {
			return '#66e0f0';
		}
		if (baseCount > count) {
			const ratio = (baseCount - count) / minDiff;
			const ratioM = (ratio * 96 + 16) | 0;
			const C = 255 - Math.abs(255 - (ratioM << 1));
			const m = (255 - ratioM) - (C >> 1);

			return 'rgb(' + (((dRdl * C) >> 8) + m) + ',' + (((dGdl * C) >> 8) + m) + ',' + (((dBdl * C) >> 8) + m) + ')';
		}

		const ratio = (count - baseCount) / maxDiff;
		const ratioM = (ratio * 96 + 16) | 0;
		const C = 255 - Math.abs(255 - (ratioM << 1));
		const m = (255 - ratioM) - (C >> 1);

		return 'rgb(' + (((dRdg * C) >> 8) + m) + ',' + (((dGdg * C) >> 8) + m) + ',' + (((dBdg * C) >> 8) + m) + ')';
	}

	function prepareRender() {
		root = undefined;
		rootLevel = 0;
		c.fillStyle = '#ffffff';
		c.fillRect(0, 0, canvasWidth, canvasHeight);
		hl.style.display = 'none';
		addTask('flame', function () {
			return false;
		});
	}

	function renderTraces(from, to) {
		prepareRender();
		addTask('flamePrepare', () => {
			let [framesBuffer, sampleToChunkPos, sampleToStorageDelta, longSamplesBuffer] = prepareFrames(from, to);
			let nextFramesBuffer = allocateHugeArray();

			levels.length = 0;

			let levelToRedraw = 0;

			const ctx = {
				frames: framesBuffer,
				nextFrames: nextFramesBuffer,
				sampleToChunkPos: sampleToChunkPos,
				sampleToStorageDelta: sampleToStorageDelta,
				longSamplesBuffer: longSamplesBuffer,
				level: 0,
				chunksToStorage: currentHeatmap.blocksData.chunksToStorage,
				storage: currentHeatmap.blocksData.storage,
				sampleToChunkEnds: currentHeatmap.blocksData.sampleToChunkEnds,
				storageSizes: currentHeatmap.blocksData.storageSizes,
				methodsBuffer: new Uint32Array(methods.c.length + 1),
				methodsBufferTheOnlyChunks: new Uint32Array(methods.c.length + 1),
				methodsBufferLongSamples: new Uint32Array(methods.c.length + 1),
				methodsBufferDirectSamples: new Uint32Array(methods.c.length + 1),

				startX: 0,
				theOnlyChunksCount: 0,
				longSamplesChunksCount: 0,
				directSamplesCount: 0,

				framesPointer: 0,
				nextFramesPointer: 0,
				nextFramesCount: 0,
				methodsMapFirstPos: 0,
			};

			addTask('flame', () => {
					ctx.level = levels.length;
					const roots = nextFrames(ctx);
					if (roots.length === 0) {
						if (levels.length === 0) {
							levels.push([{left: 0, width: 0, color: methods.c[0], title: methods.n[0], method: 0}]);
						}
						renderWithMatch(levels.length * 16, root, rootLevel);
						return false;
					}

					const tmp = ctx.nextFrames;
					ctx.nextFrames = ctx.frames;
					ctx.frames = tmp;

					levels.push(roots);

					return true;
				},
				() => {
					renderWithMatch(4096, root, rootLevel, levelToRedraw);
					levelToRedraw = levels.length;
				});
			return false;
		});
	}

	function renderTracesDiff(from, to, baseFrom, baseTo) {
		prepareRender();
		let [framesBuffer, sampleToChunkPos, sampleToStorageDelta] = prepareFramesDiff(from, to, baseFrom, baseTo);
		let nextFramesBuffer = allocateHugeArray();

		levels.length = 0;

		let levelToRedraw = 0;

		let minDiff = 1;
		let maxDiff = 1;
		const ctx = {
			frames: framesBuffer,
			nextFrames: nextFramesBuffer,
			sampleToChunkPos: sampleToChunkPos,
			sampleToStorageDelta: sampleToStorageDelta,
			level: 0,
			chunksToStorage: currentHeatmap.blocksData.chunksToStorage,
			storage: currentHeatmap.blocksData.storage,
			sampleToChunkEnds: currentHeatmap.blocksData.sampleToChunkEnds,
			storageSizes: currentHeatmap.blocksData.storageSizes,

			methodsBuffer: new Uint32Array(methods.c.length + 1),
			methodsBufferTheOnlyChunks: new Uint32Array(methods.c.length + 1),
			methodsBufferDirectSamples: new Uint32Array(methods.c.length + 1),
			baseMethodsBuffer: new Uint32Array(methods.c.length + 1),
			baseMethodsBufferTheOnlyChunks: new Uint32Array(methods.c.length + 1),
			baseMethodsBufferDirectSamples: new Uint32Array(methods.c.length + 1),

			startX: 0,
			theOnlyChunksCount: 0,
			directSamplesCount: 0,
			baseTheOnlyChunksCount: 0,
			baseDirectSamplesCount: 0,

			framesPointer: 0,
			nextFramesPointer: 0,
			nextFramesCount: 0,
			methodsMapFirstPos: 0,
		};

		addTask('flame', function () {
				ctx.level = levels.length;
				const roots = nextFramesDiff(ctx);
				if (roots.length === 0) {
					if (levels.length === 0) {
						levels.push([{left: 0, width: 0, color: methods.c[0], title: methods.n[0], method: 0}]);
					}
					renderWithMatch(levels.length * 16, root, rootLevel);
					return false;
				}

				for (let root of roots) {
					if (root.baseWidth >= root.width) {
						minDiff = Math.max(minDiff, root.baseWidth - root.width);
					} else {
						maxDiff = Math.max(maxDiff, root.width - root.baseWidth);
					}
				}

				for (let root of roots) {
					root.color = diffColor(root.width, root.baseWidth, minDiff, maxDiff);
					root.title = root.title + " (" + root.width + "/" + root.baseWidth + ")";
				}

				const tmpBuffer = ctx.nextFrames;
				ctx.nextFrames = ctx.frames;
				ctx.frames = tmpBuffer;

				levels.push(roots);
				return true;
			},
			function () {
				renderWithMatch(4096, root, rootLevel, levelToRedraw);
				levelToRedraw = levels.length;
			});
	}

	function renderTracesReversed(from, to) {
		prepareRender();
		addTask('flamePrepare', () => {
			let [framesBuffer, sampleToChunkPos, sampleToStorageDelta, longSamplesBuffer] = prepareFramesReversed(from, to);
			let nextFramesBuffer = allocateHugeArray();

			levels.length = 0;

			let levelToRedraw = 0;

			const ctx = {
				frames: framesBuffer,
				nextFrames: nextFramesBuffer,
				sampleToChunkPos: sampleToChunkPos,
				sampleToStorageDelta: sampleToStorageDelta,
				longSamplesBuffer: longSamplesBuffer,
				level: 0,
				chunksToStorage: currentHeatmap.blocksData.chunksToStorage,
				storage: currentHeatmap.blocksData.storage,
				sampleToChunkEnds: currentHeatmap.blocksData.sampleToChunkEnds,
				storageSizes: currentHeatmap.blocksData.storageSizes,
				methodsBuffer: new Uint32Array(methods.c.length + 1),
				methodsBufferTheOnlyChunks: new Uint32Array(methods.c.length + 1),
				methodsBufferDirectSamples: new Uint32Array(methods.c.length + 1),

				startX: 0,
				theOnlyChunksCount: 0,
				directSamplesCount: 0,

				framesPointer: 0,
				nextFramesPointer: 0,
				nextFramesCount: 0,
				methodsMapFirstPos: 0,
			};

			addTask('flame', () => {
					ctx.level = levels.length;
					const roots = nextFramesReversed(ctx);
					if (roots.length === 0) {
						if (levels.length === 0) {
							levels.push([{left: 0, width: 0, color: methods.c[0], title: methods.n[0], method: 0}]);
						}
						renderWithMatch(levels.length * 16, root, rootLevel);
						return false;
					}

					const tmp = ctx.nextFrames;
					ctx.nextFrames = ctx.frames;
					ctx.frames = tmp;

					levels.push(roots);

					return true;
				},
				() => {
					renderWithMatch(4096, root, rootLevel, levelToRedraw);
					levelToRedraw = levels.length;
				});
			return false;
		});
	}

	function renderTracesReversedDiff(from, to, baseFrom, baseTo) {
		prepareRender();
		let [framesBuffer, sampleToChunkPos, sampleToStorageDelta] = prepareFramesReversedDiff(from, to, baseFrom, baseTo);
		let nextFramesBuffer = allocateHugeArray();

		levels.length = 0;

		let levelToRedraw = 0;

		let minDiff = 1;
		let maxDiff = 1;
		const ctx = {
			frames: framesBuffer,
			nextFrames: nextFramesBuffer,
			sampleToChunkPos: sampleToChunkPos,
			sampleToStorageDelta: sampleToStorageDelta,
			level: 0,
			chunksToStorage: currentHeatmap.blocksData.chunksToStorage,
			storage: currentHeatmap.blocksData.storage,
			sampleToChunkEnds: currentHeatmap.blocksData.sampleToChunkEnds,
			storageSizes: currentHeatmap.blocksData.storageSizes,

			methodsBuffer: new Uint32Array(methods.c.length + 1),
			methodsBufferTheOnlyChunks: new Uint32Array(methods.c.length + 1),
			methodsBufferDirectSamples: new Uint32Array(methods.c.length + 1),
			baseMethodsBuffer: new Uint32Array(methods.c.length + 1),
			baseMethodsBufferTheOnlyChunks: new Uint32Array(methods.c.length + 1),
			baseMethodsBufferDirectSamples: new Uint32Array(methods.c.length + 1),

			startX: 0,
			theOnlyChunksCount: 0,
			directSamplesCount: 0,
			baseTheOnlyChunksCount: 0,
			baseDirectSamplesCount: 0,

			framesPointer: 0,
			nextFramesPointer: 0,
			nextFramesCount: 0,
			methodsMapFirstPos: 0,
		};

		addTask('flame', function () {
				ctx.level = levels.length;
				const roots = nextFramesReversedDiff(ctx);
				if (roots.length === 0) {
					if (levels.length === 0) {
						levels.push([{left: 0, width: 0, color: methods.c[0], title: methods.n[0], method: 0}]);
					}
					renderWithMatch(levels.length * 16, root, rootLevel);
					return false;
				}

				for (let root of roots) {
					if (root.baseWidth >= root.width) {
						minDiff = Math.max(minDiff, root.baseWidth - root.width);
					} else {
						maxDiff = Math.max(maxDiff, root.width - root.baseWidth);
					}
				}

				for (let root of roots) {
					root.color = diffColor(root.width, root.baseWidth, minDiff, maxDiff);
					root.title = root.title + " (" + root.width + "/" + root.baseWidth + ")";
				}

				const tmpBuffer = ctx.nextFrames;
				ctx.nextFrames = ctx.frames;
				ctx.frames = tmpBuffer;

				levels.push(roots);
				return true;
			},
			function () {
				renderWithMatch(4096, root, rootLevel, levelToRedraw);
				levelToRedraw = levels.length;
			});
	}

	function renderSelfDominators(from, to) {
		prepareRender();
		addTask('flamePrepare', () => {
			const chunksToStorage = currentHeatmap.blocksData.chunksToStorage;
			const sampleToChunkEnds = currentHeatmap.blocksData.sampleToChunkEnds;
			const storage = currentHeatmap.blocksData.storage;
			const counts = currentHeatmap.blocksData.counts;

			const countBeforeFirstBlock = getCount(counts, from - 1);
			const countAtLastBlock = getCount(counts, to);

			const methodsCount = new Uint32Array(methods.c.length);
			const methodsBuffer = new Uint32Array(methods.c.length);
			let methodsInBuffer = 0;
			let maxCount = 0;

			for (let sampleIndex = countBeforeFirstBlock; sampleIndex < countAtLastBlock; sampleIndex++) {
				const chunkEndPos = sampleToChunkEnds[sampleIndex];
				const storagePos = chunksToStorage[chunkEndPos - 1];
				const method = storage[storagePos];
				const oldCount = methodsCount[method]++;
				if (isNaN(oldCount)) {
					throw "old count is nan";
				}
				if (oldCount === 0) {
					methodsBuffer[methodsInBuffer++] = method;
				}
				maxCount = Math.max(maxCount, oldCount);
			}

			sort(methodsBuffer, 0, methodsInBuffer, methodsCount, 1 << (31 - Math.clz32(maxCount + 1)));
			levels.length = 0;
			for (let i = 0; i < methodsInBuffer; i++) {
				const method = methodsBuffer[i];
				levels.push([{
					left: 0,
					width: methodsCount[method],
					color: methods.c[method],
					title: methods.n[method],
					method: method
				}]);
			}
			renderWithMatch(levels.length * 16, root, rootLevel);
			return false;
		});
	}

	function renderSelfDominatorsDiff(from, to, baseFrom, baseTo) {
		prepareRender();
		addTask('flamePrepare', () => {
			const chunksToStorage = currentHeatmap.blocksData.chunksToStorage;
			const sampleToChunkEnds = currentHeatmap.blocksData.sampleToChunkEnds;
			const storage = currentHeatmap.blocksData.storage;
			const counts = currentHeatmap.blocksData.counts;

			const countBeforeFirstBlock = getCount(counts, from - 1);
			const countAtLastBlock = getCount(counts, to);

			const baseCountBeforeFirstBlock = getCount(counts, baseFrom - 1);
			const baseCountAtLastBlock = getCount(counts, baseTo);

			const methodsCount = new Uint32Array(methods.c.length);
			const baseMethodsCount = new Uint32Array(methods.c.length);
			const methodsBuffer = new Uint32Array(methods.c.length);
			let methodsInBuffer = 0;
			let maxCount = 1;
			let minDiff = 1;
			let maxDiff = 1;

			for (let sampleIndex = countBeforeFirstBlock; sampleIndex < countAtLastBlock; sampleIndex++) {
				const chunkEndPos = sampleToChunkEnds[sampleIndex];
				const storagePos = chunksToStorage[chunkEndPos - 1];
				const method = storage[storagePos];
				const oldCount = methodsCount[method]++;
				if (oldCount === 0) {
					methodsBuffer[methodsInBuffer++] = method;
				}
				maxCount = Math.max(maxCount, oldCount);
			}

			for (let sampleIndex = baseCountBeforeFirstBlock; sampleIndex < baseCountAtLastBlock; sampleIndex++) {
				const chunkEndPos = sampleToChunkEnds[sampleIndex];
				const storagePos = chunksToStorage[chunkEndPos - 1];
				const method = storage[storagePos];
				const oldCount = baseMethodsCount[method]++;
				if (oldCount === 0 && methodsCount[method] === 0) {
					methodsBuffer[methodsInBuffer++] = method;
				}
			}

			for (let i = 0; i < methodsInBuffer; i++) {
				const method = methodsBuffer[i];
				const count = methodsCount[method];
				const baseCount = baseMethodsCount[method];

				if (baseCount > count) {
					minDiff = Math.max(minDiff, baseCount - count);
				} else {
					maxDiff = Math.max(maxDiff, count - baseCount);
				}
			}

			sort(methodsBuffer, 0, methodsInBuffer, methodsCount, 1 << (31 - Math.clz32(maxCount)));

			levels.length = 0;
			for (let i = 0; i < methodsInBuffer; i++) {
				const method = methodsBuffer[i];
				const count = methodsCount[method];
				const baseCount = baseMethodsCount[method];
				const title = methods.n[method] + " (" + count + "/" + baseCount + ")"

				let color = diffColor(count, baseCount, minDiff, maxDiff);
				levels.push([{left: 0, width: count, color: color, title: title, method: method}]);
			}
			renderWithMatch(levels.length * 16, root, rootLevel);
			return false;
		});
	}

	function prepareFrames(from, to) {
		const chunksToStorage = currentHeatmap.blocksData.chunksToStorage;
		const sampleToChunkEnds = currentHeatmap.blocksData.sampleToChunkEnds;
		const storageSizes = currentHeatmap.blocksData.storageSizes;
		const counts = currentHeatmap.blocksData.counts;

		const countBeforeFirstBlock = getCount(counts, from - 1);
		const countAtLastBlock = getCount(counts, to);

		const theOnlyChunksBuffer = allocateHugeArray();
		const firstChunkPosOfLongSamplesBuffer = allocateHugeArray();
		const sampleToChunkPos = new Uint32Array(sampleToChunkEnds.length);
		const sampleToStorageDelta = new Uint32Array(sampleToChunkEnds.length);
		const firstChunkPosOfLongSamples = new Uint32Array(storageSizes.length);
		const theOnlyChunks = new Uint32Array(storageSizes.length);

		let theOnlyChunksBufferPos = 0;

		let firstChunkPosOfLongSamplesPos = 0;
		let totalCountLongSamples = 0;
		let count = 0;
		for (let sampleIndex = countBeforeFirstBlock; sampleIndex < countAtLastBlock; sampleIndex++) {
			if (filterOut(sampleIndex)) {
				continue;
			}
			count++;
			const chunkPos = sampleToChunkEnds[sampleIndex - 1] || 0;
			const chunkEndPos = sampleToChunkEnds[sampleIndex];
			const storagePos = chunksToStorage[chunkPos];
			if (chunkPos + 1 === chunkEndPos) {
				if (theOnlyChunks[storagePos]++ === 0) {
					theOnlyChunksBuffer[theOnlyChunksBufferPos++] = storagePos;
				}
			} else {
				if (firstChunkPosOfLongSamples[storagePos]++ === 0) {
					firstChunkPosOfLongSamplesBuffer[firstChunkPosOfLongSamplesPos++] = storagePos;
				}
				totalCountLongSamples++;
			}
		}

		const framesBuffer = allocateHugeArray();
		framesBuffer[0] = count === 0 ? 0 : 1;    // frames count on this level

		framesBuffer[1] = 0;    // methodId
		framesBuffer[2] = 0;    // x
		framesBuffer[3] = count;
		framesBuffer[4] = theOnlyChunksBufferPos;
		framesBuffer[5] = firstChunkPosOfLongSamplesPos;
		framesBuffer[6] = 0;    // direct samples count

		let framesBufferPos = 7;

		for (let storagePosIndex = 0; storagePosIndex < theOnlyChunksBufferPos; storagePosIndex++) {
			const storagePos = theOnlyChunksBuffer[storagePosIndex];
			framesBuffer[framesBufferPos++] = storagePos;
			framesBuffer[framesBufferPos++] = theOnlyChunks[storagePos];
		}

		const longSamplesBuffer = new Uint32Array(totalCountLongSamples);
		let longSamplesBufferPos = 0;
		for (let storagePosIndex = 0; storagePosIndex < firstChunkPosOfLongSamplesPos; storagePosIndex++) {
			const storagePos = firstChunkPosOfLongSamplesBuffer[storagePosIndex];
			const count = firstChunkPosOfLongSamples[storagePos];
			framesBuffer[framesBufferPos++] = storagePos;
			framesBuffer[framesBufferPos++] = count;
			framesBuffer[framesBufferPos++] = longSamplesBufferPos;

			firstChunkPosOfLongSamples[storagePos] = longSamplesBufferPos;
			longSamplesBufferPos += count;
		}

		for (let sampleIndex = countBeforeFirstBlock; sampleIndex < countAtLastBlock; sampleIndex++) {
			if (filterOut(sampleIndex)) {
				continue;
			}
			const chunkPos = sampleToChunkEnds[sampleIndex - 1] || 0;
			const chunkEndPos = sampleToChunkEnds[sampleIndex];
			const storagePos = chunksToStorage[chunkPos];
			if (chunkPos + 1 !== chunkEndPos) {
				longSamplesBuffer[firstChunkPosOfLongSamples[storagePos]++] = sampleIndex;
			}
		}

		return [framesBuffer, sampleToChunkPos, sampleToStorageDelta, longSamplesBuffer];
	}

	function prepareFramesDiff(from, to, baseFrom, baseTo) {
		const chunksToStorage = currentHeatmap.blocksData.chunksToStorage;
		const sampleToChunkEnds = currentHeatmap.blocksData.sampleToChunkEnds;
		const storageSizes = currentHeatmap.blocksData.storageSizes;
		const counts = currentHeatmap.blocksData.counts;

		const countBeforeFirstBlock = getCount(counts, from - 1);
		const countAtLastBlock = getCount(counts, to);

		const baseCountBeforeFirstBlock = getCount(counts, baseFrom - 1);
		const baseCountAtLastBlock = getCount(counts, baseTo);

		const theOnlyChunksBuffer = allocateHugeArray();
		const sampleToChunkPos = new Uint32Array(sampleToChunkEnds.length);
		const sampleToStorageDelta = new Uint32Array(sampleToChunkEnds.length);
		const theOnlyChunks = new Uint32Array(storageSizes.length);
		const baseTheOnlyChunks = new Uint32Array(storageSizes.length);

		let theOnlyChunksBufferPos = 0;
		let singleSamplesCount = 0;
		let count = 0;
		for (let sampleIndex = countBeforeFirstBlock; sampleIndex < countAtLastBlock; sampleIndex++) {
			if (filterOut(sampleIndex)) {
				continue;
			}
			count++;
			const chunkPos = sampleToChunkEnds[sampleIndex - 1] || 0;
			const chunkEndPos = sampleToChunkEnds[sampleIndex];
			if (chunkPos + 1 === chunkEndPos) {
				const storagePos = chunksToStorage[chunkPos];
				if (theOnlyChunks[storagePos]++ === 0) {
					theOnlyChunksBuffer[theOnlyChunksBufferPos++] = storagePos;
				}
			} else {
				singleSamplesCount++;
			}
		}

		const theOnlyChunksCount = theOnlyChunksBufferPos;
		let baseSingleSamplesCount = 0;
		let baseCount = 0;
		for (let sampleIndex = baseCountBeforeFirstBlock; sampleIndex < baseCountAtLastBlock; sampleIndex++) {
			if (filterOut(sampleIndex)) {
				continue;
			}
			baseCount++;
			const chunkPos = sampleToChunkEnds[sampleIndex - 1] || 0;
			const chunkEndPos = sampleToChunkEnds[sampleIndex];
			if (chunkPos + 1 === chunkEndPos) {
				const storagePos = chunksToStorage[chunkPos];
				if (baseTheOnlyChunks[storagePos]++ === 0) {
					theOnlyChunksBuffer[theOnlyChunksBufferPos++] = storagePos;
				}
			} else {
				baseSingleSamplesCount++;
			}
		}

		const framesBuffer = allocateHugeArray();
		framesBuffer[0] = 1;    // frames count on this level

		framesBuffer[1] = 0;    // methodId
		framesBuffer[2] = 0;    // x
		framesBuffer[3] = count;
		framesBuffer[4] = theOnlyChunksCount;
		framesBuffer[5] = singleSamplesCount;
		framesBuffer[6] = baseCount;
		framesBuffer[7] = theOnlyChunksBufferPos - theOnlyChunksCount;
		framesBuffer[8] = baseSingleSamplesCount;

		let framesBufferPos = 9;

		for (let storagePosIndex = 0; storagePosIndex < theOnlyChunksCount; storagePosIndex++) {
			const storagePos = theOnlyChunksBuffer[storagePosIndex];
			framesBuffer[framesBufferPos++] = storagePos;
			framesBuffer[framesBufferPos++] = theOnlyChunks[storagePos];
		}

		for (let sampleIndex = countBeforeFirstBlock; sampleIndex < countAtLastBlock; sampleIndex++) {
			if (filterOut(sampleIndex)) {
				continue;
			}
			const chunkPos = sampleToChunkEnds[sampleIndex - 1] || 0;
			const chunkEndPos = sampleToChunkEnds[sampleIndex];
			if (chunkPos + 1 !== chunkEndPos) {
				sampleToChunkPos[sampleIndex] = chunkPos;

				const storagePos = chunksToStorage[chunkPos];
				sampleToStorageDelta[sampleIndex] = storageSizes[storagePos] | 0x80000000;

				framesBuffer[framesBufferPos++] = sampleIndex;
			}
		}

		for (let storagePosIndex = theOnlyChunksCount; storagePosIndex < theOnlyChunksBufferPos; storagePosIndex++) {
			const storagePos = theOnlyChunksBuffer[storagePosIndex];
			framesBuffer[framesBufferPos++] = storagePos;
			framesBuffer[framesBufferPos++] = baseTheOnlyChunks[storagePos];
		}

		for (let sampleIndex = baseCountBeforeFirstBlock; sampleIndex < baseCountAtLastBlock; sampleIndex++) {
			if (filterOut(sampleIndex)) {
				continue;
			}
			const chunkPos = sampleToChunkEnds[sampleIndex - 1] || 0;
			const chunkEndPos = sampleToChunkEnds[sampleIndex];
			if (chunkPos + 1 !== chunkEndPos) {
				if (sampleToStorageDelta[sampleIndex] === 0) {
					sampleToChunkPos[sampleIndex] = chunkPos;

					const storagePos = chunksToStorage[chunkPos];
					sampleToStorageDelta[sampleIndex] = storageSizes[storagePos];
				}
				framesBuffer[framesBufferPos++] = sampleIndex;
			}
		}

		return [framesBuffer, sampleToChunkPos, sampleToStorageDelta];
	}

	function prepareFramesReversed(from, to) {
		const chunksToStorage = currentHeatmap.blocksData.chunksToStorage;
		const sampleToChunkEnds = currentHeatmap.blocksData.sampleToChunkEnds;
		const storageSizes = currentHeatmap.blocksData.storageSizes;
		const counts = currentHeatmap.blocksData.counts;

		const countBeforeFirstBlock = getCount(counts, from - 1);
		const countAtLastBlock = getCount(counts, to);

		const theOnlyChunksBuffer = allocateHugeArray();
		const sampleToChunkPos = new Uint32Array(sampleToChunkEnds.length);
		const sampleToStorageDelta = new Uint32Array(sampleToChunkEnds.length);
		const theOnlyChunks = new Uint32Array(storageSizes.length);

		let theOnlyChunksBufferPos = 0;
		let singleSamplesCount = 0;
		let count = 0;
		for (let sampleIndex = countBeforeFirstBlock; sampleIndex < countAtLastBlock; sampleIndex++) {
			if (filterOut(sampleIndex)) {
				continue;
			}
			count++;
			const chunkPos = sampleToChunkEnds[sampleIndex - 1] || 0;
			const chunkEndPos = sampleToChunkEnds[sampleIndex];
			if (chunkPos === chunkEndPos - 1) {
				const storagePos = chunksToStorage[chunkPos];
				if (theOnlyChunks[storagePos]++ === 0) {
					theOnlyChunksBuffer[theOnlyChunksBufferPos++] = storagePos;
				}
			} else {
				singleSamplesCount++;
			}
		}

		const framesBuffer = allocateHugeArray();
		framesBuffer[0] = count === 0 ? 0 : 1;    // frames count on this level

		framesBuffer[1] = 0;    // methodId
		framesBuffer[2] = 0;    // x
		framesBuffer[3] = count;
		framesBuffer[4] = theOnlyChunksBufferPos;
		framesBuffer[5] = singleSamplesCount;    // direct samples count

		let framesBufferPos = 6;

		for (let storagePosIndex = 0; storagePosIndex < theOnlyChunksBufferPos; storagePosIndex++) {
			const storagePos = theOnlyChunksBuffer[storagePosIndex];
			framesBuffer[framesBufferPos++] = storagePos;
			framesBuffer[framesBufferPos++] = theOnlyChunks[storagePos];
		}

		for (let sampleIndex = countBeforeFirstBlock; sampleIndex < countAtLastBlock; sampleIndex++) {
			if (filterOut(sampleIndex)) {
				continue;
			}
			const chunkPos = sampleToChunkEnds[sampleIndex - 1] || 0;
			const chunkEndPos = sampleToChunkEnds[sampleIndex];
			if (chunkPos !== chunkEndPos - 1) {
				sampleToChunkPos[sampleIndex] = chunkEndPos - 1;
				sampleToStorageDelta[sampleIndex] = 0;

				framesBuffer[framesBufferPos++] = sampleIndex;
			}
		}

		return [framesBuffer, sampleToChunkPos, sampleToStorageDelta];
	}

	function prepareFramesReversedDiff(from, to, baseFrom, baseTo) {
		const chunksToStorage = currentHeatmap.blocksData.chunksToStorage;
		const sampleToChunkEnds = currentHeatmap.blocksData.sampleToChunkEnds;
		const storageSizes = currentHeatmap.blocksData.storageSizes;
		const counts = currentHeatmap.blocksData.counts;

		const countBeforeFirstBlock = getCount(counts, from - 1);
		const countAtLastBlock = getCount(counts, to);

		const baseCountBeforeFirstBlock = getCount(counts, baseFrom - 1);
		const baseCountAtLastBlock = getCount(counts, baseTo);

		const theOnlyChunksBuffer = allocateHugeArray();
		const sampleToChunkPos = new Uint32Array(sampleToChunkEnds.length);
		const sampleToStorageDelta = new Uint32Array(sampleToChunkEnds.length);
		const theOnlyChunks = new Uint32Array(storageSizes.length);
		const baseTheOnlyChunks = new Uint32Array(storageSizes.length);

		let theOnlyChunksBufferPos = 0;
		let singleSamplesCount = 0;
		let count = 0;
		for (let sampleIndex = countBeforeFirstBlock; sampleIndex < countAtLastBlock; sampleIndex++) {
			if (filterOut(sampleIndex)) {
				continue;
			}
			count++;
			const chunkPos = sampleToChunkEnds[sampleIndex - 1] || 0;
			const chunkEndPos = sampleToChunkEnds[sampleIndex];
			if (chunkPos + 1 === chunkEndPos) {
				const storagePos = chunksToStorage[chunkPos];
				if (theOnlyChunks[storagePos]++ === 0) {
					theOnlyChunksBuffer[theOnlyChunksBufferPos++] = storagePos;
				}
			} else {
				singleSamplesCount++;
			}
		}

		const theOnlyChunksCount = theOnlyChunksBufferPos;
		let baseSingleSamplesCount = 0;
		let baseCount = 0;
		for (let sampleIndex = baseCountBeforeFirstBlock; sampleIndex < baseCountAtLastBlock; sampleIndex++) {
			if (filterOut(sampleIndex)) {
				continue;
			}
			baseCount++;
			const chunkPos = sampleToChunkEnds[sampleIndex - 1] || 0;
			const chunkEndPos = sampleToChunkEnds[sampleIndex];
			if (chunkPos + 1 === chunkEndPos) {
				const storagePos = chunksToStorage[chunkPos];
				if (baseTheOnlyChunks[storagePos]++ === 0) {
					theOnlyChunksBuffer[theOnlyChunksBufferPos++] = storagePos;
				}
			} else {
				baseSingleSamplesCount++;
			}
		}

		const framesBuffer = allocateHugeArray();
		framesBuffer[0] = 1;    // frames count on this level

		framesBuffer[1] = 0;    // methodId
		framesBuffer[2] = 0;    // x
		framesBuffer[3] = count;
		framesBuffer[4] = theOnlyChunksCount;
		framesBuffer[5] = singleSamplesCount;
		framesBuffer[6] = baseCount;
		framesBuffer[7] = theOnlyChunksBufferPos - theOnlyChunksCount;
		framesBuffer[8] = baseSingleSamplesCount;

		let framesBufferPos = 9;

		for (let storagePosIndex = 0; storagePosIndex < theOnlyChunksCount; storagePosIndex++) {
			const storagePos = theOnlyChunksBuffer[storagePosIndex];
			framesBuffer[framesBufferPos++] = storagePos;
			framesBuffer[framesBufferPos++] = theOnlyChunks[storagePos];
		}

		for (let sampleIndex = countBeforeFirstBlock; sampleIndex < countAtLastBlock; sampleIndex++) {
			if (filterOut(sampleIndex)) {
				continue;
			}
			const chunkPos = sampleToChunkEnds[sampleIndex - 1] || 0;
			const chunkEndPos = sampleToChunkEnds[sampleIndex];
			if (chunkPos + 1 !== chunkEndPos) {
				sampleToChunkPos[sampleIndex] = chunkEndPos - 1;
				sampleToStorageDelta[sampleIndex] = 0x80000000;

				framesBuffer[framesBufferPos++] = sampleIndex;
			}
		}

		for (let storagePosIndex = theOnlyChunksCount; storagePosIndex < theOnlyChunksBufferPos; storagePosIndex++) {
			const storagePos = theOnlyChunksBuffer[storagePosIndex];
			framesBuffer[framesBufferPos++] = storagePos;
			framesBuffer[framesBufferPos++] = baseTheOnlyChunks[storagePos];
		}

		for (let sampleIndex = baseCountBeforeFirstBlock; sampleIndex < baseCountAtLastBlock; sampleIndex++) {
			if (filterOut(sampleIndex)) {
				continue;
			}
			const chunkPos = sampleToChunkEnds[sampleIndex - 1] || 0;
			const chunkEndPos = sampleToChunkEnds[sampleIndex];
			if (chunkPos + 1 !== chunkEndPos) {
				if (sampleToStorageDelta[sampleIndex] === 0) {
					sampleToChunkPos[sampleIndex] = chunkEndPos - 1;
					sampleToStorageDelta[sampleIndex] = 0x80000000;
				}
				framesBuffer[framesBufferPos++] = sampleIndex;
			}
		}

		return [framesBuffer, sampleToChunkPos, sampleToStorageDelta];
	}

	function filterOut(sample) {
		if (!filterFrames) {
			return false;
		}
		const sampleMarks = currentHeatmap.blocksData.sampleMarks;
		return (sampleMarks[sample >> 5] & (1 << (sample & 31))) === 0;
	}

	function nextFrames(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;

		ctx.startX = 0;
		ctx.theOnlyChunksCount = 0;
		ctx.longSamplesChunksCount = 0;
		ctx.directSamplesCount = 0;

		ctx.nextFramesPointer = 1; // one reserved to place nextFramesCount
		ctx.nextFramesCount = 0;

		let fp = 0;
		const framesCount = frames[fp++];

		const roots = new Array(framesCount);
		for (let frame = 0; frame < framesCount; frame++) {
			const methodId = frames[fp++];
			const x = frames[fp++];
			const childrenCount = frames[fp++];

			ctx.startX = x;
			ctx.theOnlyChunksCount = frames[fp++];
			ctx.longSamplesChunksCount = frames[fp++];
			ctx.directSamplesCount = frames[fp++];

			roots[frame] = {
				left: x,
				width: childrenCount,
				color: methods.c[methodId],
				title: methods.n[methodId],
				details: methods.b[methodId],
				method: methodId
			};

			ctx.framesPointer = fp;
			ctx.methodsMapFirstPos = ctx.nextFrames.length;
			processFrame(ctx)
			fp = ctx.framesPointer;
		}

		nextFrames[0] = ctx.nextFramesCount;

		return roots;
	}

	function nextFramesDiff(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;

		ctx.startX = 0;
		ctx.theOnlyChunksCount = 0;
		ctx.directSamplesCount = 0;

		ctx.nextFramesPointer = 1; // one reserved to place nextFramesCount
		ctx.nextFramesCount = 0;

		let fp = 0;
		const framesCount = frames[fp++];

		const roots = new Array(framesCount);
		for (let frame = 0; frame < framesCount; frame++) {
			const methodId = frames[fp++];
			let x = frames[fp++];

			const childrenCount = frames[fp++];
			const theOnlyChunksCount = frames[fp++];
			const directSamplesCount = frames[fp++];

			const baseChildrenCount = frames[fp++];
			const baseTheOnlyChunksCount = frames[fp++];
			const baseDirectSamplesCount = frames[fp++];

			ctx.startX = x;
			ctx.theOnlyChunksCount = theOnlyChunksCount;
			ctx.directSamplesCount = directSamplesCount;
			ctx.baseChildrenCount = baseChildrenCount;
			ctx.baseTheOnlyChunksCount = baseTheOnlyChunksCount;
			ctx.baseDirectSamplesCount = baseDirectSamplesCount;

			roots[frame] = {
				left: x,
				width: childrenCount,
				baseWidth: baseChildrenCount,
				color: methods.c[methodId],
				title: methods.n[methodId],
				details: methods.b[methodId],
				method: methodId,
			};

			ctx.framesPointer = fp;
			ctx.methodsMapFirstPos = ctx.nextFrames.length;
			processFrameDiff(ctx)
			fp = ctx.framesPointer;
		}

		nextFrames[0] = ctx.nextFramesCount;

		return roots;
	}

	function nextFramesReversed(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;

		ctx.startX = 0;
		ctx.theOnlyChunksCount = 0;
		ctx.directSamplesCount = 0;

		ctx.nextFramesPointer = 1; // one reserved to place nextFramesCount
		ctx.nextFramesCount = 0;

		let fp = 0;
		const framesCount = frames[fp++];

		const roots = new Array(framesCount);
		for (let frame = 0; frame < framesCount; frame++) {
			const methodId = frames[fp++];
			const x = frames[fp++];
			const childrenCount = frames[fp++];

			ctx.startX = x;
			ctx.theOnlyChunksCount = frames[fp++];
			ctx.directSamplesCount = frames[fp++];

			roots[frame] = {
				left: x,
				width: childrenCount,
				color: methods.c[methodId],
				title: methods.n[methodId],
				details: methods.b[methodId],
				method: methodId
			};

			ctx.framesPointer = fp;
			ctx.methodsMapFirstPos = ctx.nextFrames.length;
			processFrameReversed(ctx)
			fp = ctx.framesPointer;
		}

		nextFrames[0] = ctx.nextFramesCount;

		return roots;
	}

	function nextFramesReversedDiff(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;

		ctx.startX = 0;
		ctx.theOnlyChunksCount = 0;
		ctx.directSamplesCount = 0;

		ctx.nextFramesPointer = 1; // one reserved to place nextFramesCount
		ctx.nextFramesCount = 0;

		let fp = 0;
		const framesCount = frames[fp++];

		const roots = new Array(framesCount);
		for (let frame = 0; frame < framesCount; frame++) {
			const methodId = frames[fp++];
			let x = frames[fp++];

			const childrenCount = frames[fp++];
			const theOnlyChunksCount = frames[fp++];
			const directSamplesCount = frames[fp++];

			const baseChildrenCount = frames[fp++];
			const baseTheOnlyChunksCount = frames[fp++];
			const baseDirectSamplesCount = frames[fp++];

			ctx.startX = x;
			ctx.theOnlyChunksCount = theOnlyChunksCount;
			ctx.directSamplesCount = directSamplesCount;
			ctx.baseChildrenCount = baseChildrenCount;
			ctx.baseTheOnlyChunksCount = baseTheOnlyChunksCount;
			ctx.baseDirectSamplesCount = baseDirectSamplesCount;

			roots[frame] = {
				left: x,
				width: childrenCount,
				baseWidth: baseChildrenCount,
				color: methods.c[methodId],
				title: methods.n[methodId],
				details: methods.b[methodId],
				method: methodId,
			};

			ctx.framesPointer = fp;
			ctx.methodsMapFirstPos = ctx.nextFrames.length;
			processFrameReversedDiff(ctx)
			fp = ctx.framesPointer;
		}

		nextFrames[0] = ctx.nextFramesCount;

		return roots;
	}

	function processFrame(ctx) {
		const startFramesPointer = ctx.framesPointer;

		// the main idea is to go through the samples and calculate total amount of samples for every method, using method buffers
		let totalChildren = 0;
		// calculates count of each method in methodsBufferTheOnlyChunks (for the-only-one-chunk samples)
		totalChildren += prepareTheOnlyChunks(ctx);
		// calculates count of each method in methodsBufferLongSamples (for long samples, that shares the first chunk)
		totalChildren += prepareLongSamplesChunks(ctx);
		// calculates count of each method in methodsBufferDirectSamples (for direct samples, expanded to list of methods)
		totalChildren += prepareDirectSamples(ctx);

		if (totalChildren === 0) {
			return;
		}

		// frames are sorted from more frequent to less frequent
		sortFramesForWrite(ctx);
		// writes frames data and reserves place for splitting samples between methods
		writeNextFrames(ctx);

		// the main idea is to go through the samples again and split them by methods into prepared buffer
		ctx.framesPointer = startFramesPointer;
		// splits the-only-one-chunk samples, skips finished samples
		splitTheOnlyChunks(ctx);
		// splits long samples, unpacks finished chunks to direct samples
		splitLongSamplesChunks(ctx);
		// splits direct samples, skips finished samples
		splitDirectSamples(ctx);

		// cleans buffers and moves nextFramesPointer
		cleanupMethodBuffers(ctx);

		const methodCount = ctx.nextFrames.length - ctx.methodsMapFirstPos;
		ctx.nextFramesCount += methodCount;
	}

	function processFrameDiff(ctx) {
		const startFramesPointer = ctx.framesPointer;

		// the main idea is to go through the samples and calculate total amount of samples for every method, using method buffers
		let totalChildren = 0;
		// calculates count of each method in methodsBufferTheOnlyChunks (for the-only-one-chunk samples)
		totalChildren += prepareTheOnlyChunks(ctx);

		// NOTE: there is no support for long samples from several chunks for diffs, they are split to direct samples.
		// It gives only 10% performance, so it is not critical for any practical case of using diffs.

		// calculates count of each method in methodsBufferDirectSamples (for direct samples, expanded to list of methods)
		totalChildren += prepareDirectSamplesDiff(ctx);

		const startBaseFramesPointer = ctx.framesPointer;
		// calculates count of each method in baseMethodsBufferTheOnlyChunks (for the-only-one-chunk samples of base)
		prepareBaseTheOnlyChunks(ctx);
		// calculates count of each method in baseMethodsBufferDirectSamples (for direct samples of base, expanded to list of methods)
		prepareBaseDirectSamples(ctx);

		if (totalChildren === 0) {
			return;
		}

		const endFramesPointer = ctx.framesPointer;

		// frames are sorted from more frequent to less frequent
		sortFramesForWrite(ctx);
		// writes frames data and reserves place for splitting samples between methods
		writeNextFramesDiff(ctx);

		// the main idea is to go through the samples again and split them by methods into prepared buffer
		// we need to start from base methods to handle the case when the same sample contained both in base and current
		ctx.framesPointer = startBaseFramesPointer;
		splitBaseTheOnlyChunks(ctx);
		splitBaseDirectSamples(ctx);

		// the main idea is to go through the samples again and split them by methods into prepared buffer
		ctx.framesPointer = startFramesPointer;
		// splits the-only-one-chunk samples, skips finished samples
		splitTheOnlyChunks(ctx);
		// splits direct samples, skips finished samples
		splitDirectSamplesDiff(ctx);

		// cleans buffers and moves nextFramesPointer
		cleanupMethodBuffersDiff(ctx);

		const methodCount = ctx.nextFrames.length - ctx.methodsMapFirstPos;
		ctx.nextFramesCount += methodCount;
		ctx.framesPointer = endFramesPointer;
	}

	function processFrameReversed(ctx) {
		const startFramesPointer = ctx.framesPointer;

		// the main idea is to go through the samples and calculate total amount of samples for every method, using method buffers
		let totalChildren = 0;
		// calculates count of each method in methodsBufferTheOnlyChunks (for the-only-one-chunk samples)
		totalChildren += prepareTheOnlyChunksReversed(ctx);
		// calculates count of each method in methodsBufferDirectSamples (for direct samples, expanded to list of methods)
		totalChildren += prepareDirectSamplesReversed(ctx);

		if (totalChildren === 0) {
			return;
		}

		// frames are sorted from more frequent to less frequent
		sortFramesForWrite(ctx);
		// writes frames data and reserves place for splitting samples between methods
		writeNextFramesReversed(ctx);

		// the main idea is to go through the samples again and split them by methods into prepared buffer
		ctx.framesPointer = startFramesPointer;
		// splits the-only-one-chunk samples, skips finished samples
		splitTheOnlyChunksReversed(ctx);
		// splits direct samples, skips finished samples
		splitDirectSamplesReversed(ctx);

		// cleans buffers and moves nextFramesPointer
		cleanupMethodBuffersReversed(ctx);

		const methodCount = ctx.nextFrames.length - ctx.methodsMapFirstPos;
		ctx.nextFramesCount += methodCount;
	}

	function processFrameReversedDiff(ctx) {
		const startFramesPointer = ctx.framesPointer;

		// the main idea is to go through the samples and calculate total amount of samples for every method, using method buffers
		let totalChildren = 0;
		// calculates count of each method in methodsBufferTheOnlyChunks (for the-only-one-chunk samples)
		totalChildren += prepareTheOnlyChunksReversed(ctx);

		// calculates count of each method in methodsBufferDirectSamples (for direct samples, expanded to list of methods)
		totalChildren += prepareDirectSamplesReversedDiff(ctx);

		const startBaseFramesPointer = ctx.framesPointer;
		// calculates count of each method in baseMethodsBufferTheOnlyChunks (for the-only-one-chunk samples of base)
		prepareBaseTheOnlyChunksReversed(ctx);
		// calculates count of each method in baseMethodsBufferDirectSamples (for direct samples of base, expanded to list of methods)
		prepareBaseDirectSamplesReversed(ctx);

		if (totalChildren === 0) {
			return;
		}

		const endFramesPointer = ctx.framesPointer;

		// frames are sorted from more frequent to less frequent
		sortFramesForWrite(ctx);
		// writes frames data and reserves place for splitting samples between methods
		writeNextFramesDiff(ctx);

		// the main idea is to go through the samples again and split them by methods into prepared buffer
		// we need to start from base methods to handle the case when the same sample contained both in base and current
		ctx.framesPointer = startBaseFramesPointer;
		splitBaseTheOnlyChunksReversed(ctx);
		splitBaseDirectSamplesReversed(ctx);

		// the main idea is to go through the samples again and split them by methods into prepared buffer
		ctx.framesPointer = startFramesPointer;
		// splits the-only-one-chunk samples, skips finished samples
		splitTheOnlyChunksReversed(ctx);
		// splits direct samples, skips finished samples
		splitDirectSamplesReversedDiff(ctx);

		// cleans buffers and moves nextFramesPointer
		cleanupMethodBuffersDiff(ctx);

		const methodCount = ctx.nextFrames.length - ctx.methodsMapFirstPos;
		ctx.nextFramesCount += methodCount;
		ctx.framesPointer = endFramesPointer;
	}

	function prepareTheOnlyChunks(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const level = ctx.level;
		const storage = ctx.storage;
		const storageSizes = ctx.storageSizes;
		const methodsBuffer = ctx.methodsBuffer;
		const methodsBufferTheOnlyChunks = ctx.methodsBufferTheOnlyChunks;

		const theOnlyChunksCount = ctx.theOnlyChunksCount;

		const levelPlusOne = level + 1;

		let fp = ctx.framesPointer;
		let methodsMapFirstPos = ctx.methodsMapFirstPos;

		let children = 0;
		for (let child = 0; child < theOnlyChunksCount; child++) {
			const storagePos = frames[fp++];
			const count = frames[fp++];
			const size = storageSizes[storagePos];
			if (size === level) {
				continue;
			}
			const methodId = storage[storagePos + size - levelPlusOne];

			if ((methodsBuffer[methodId] += count) === count) {
				nextFrames[--methodsMapFirstPos] = methodId;
			}
			methodsBufferTheOnlyChunks[methodId]++;

			children++;
		}

		ctx.framesPointer = fp;
		ctx.methodsMapFirstPos = methodsMapFirstPos;

		return children;
	}

	function prepareTheOnlyChunksReversed(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const level = ctx.level;
		const storage = ctx.storage;
		const storageSizes = ctx.storageSizes;
		const methodsBuffer = ctx.methodsBuffer;
		const methodsBufferTheOnlyChunks = ctx.methodsBufferTheOnlyChunks;

		const theOnlyChunksCount = ctx.theOnlyChunksCount;

		let fp = ctx.framesPointer;
		let methodsMapFirstPos = ctx.methodsMapFirstPos;

		let children = 0;
		for (let child = 0; child < theOnlyChunksCount; child++) {
			const storagePos = frames[fp++];
			const count = frames[fp++];
			const size = storageSizes[storagePos];
			if (size === level) {
				continue;
			}
			const methodId = storage[storagePos + level];

			if ((methodsBuffer[methodId] += count) === count) {
				nextFrames[--methodsMapFirstPos] = methodId;
			}
			methodsBufferTheOnlyChunks[methodId]++;

			children++;
		}

		ctx.framesPointer = fp;
		ctx.methodsMapFirstPos = methodsMapFirstPos;

		return children;
	}

	function prepareBaseTheOnlyChunks(ctx) {
		const frames = ctx.frames;
		const level = ctx.level;
		const storage = ctx.storage;
		const storageSizes = ctx.storageSizes;
		const methodsBuffer = ctx.methodsBuffer;
		const baseMethodsBuffer = ctx.baseMethodsBuffer;
		const baseMethodsBufferTheOnlyChunks = ctx.baseMethodsBufferTheOnlyChunks;

		const baseTheOnlyChunksCount = ctx.baseTheOnlyChunksCount;

		const levelPlusOne = level + 1;

		let fp = ctx.framesPointer;

		for (let child = 0; child < baseTheOnlyChunksCount; child++) {
			const storagePos = frames[fp++];
			const count = frames[fp++];
			const size = storageSizes[storagePos];
			if (size === level) {
				continue;
			}
			const methodId = storage[storagePos + size - levelPlusOne];

			if (methodsBuffer[methodId] !== 0) {
				baseMethodsBuffer[methodId] += count;
				baseMethodsBufferTheOnlyChunks[methodId]++;
			}
		}

		ctx.framesPointer = fp;
	}

	function prepareBaseTheOnlyChunksReversed(ctx) {
		const frames = ctx.frames;
		const level = ctx.level;
		const storage = ctx.storage;
		const storageSizes = ctx.storageSizes;
		const methodsBuffer = ctx.methodsBuffer;
		const baseMethodsBuffer = ctx.baseMethodsBuffer;
		const baseMethodsBufferTheOnlyChunks = ctx.baseMethodsBufferTheOnlyChunks;

		const baseTheOnlyChunksCount = ctx.baseTheOnlyChunksCount;

		let fp = ctx.framesPointer;

		for (let child = 0; child < baseTheOnlyChunksCount; child++) {
			const storagePos = frames[fp++];
			const count = frames[fp++];
			const size = storageSizes[storagePos];
			if (size === level) {
				continue;
			}
			const methodId = storage[storagePos + level];

			if (methodsBuffer[methodId] !== 0) {
				baseMethodsBuffer[methodId] += count;
				baseMethodsBufferTheOnlyChunks[methodId]++;
			}
		}

		ctx.framesPointer = fp;
	}

	function prepareLongSamplesChunks(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const longSamplesBuffer = ctx.longSamplesBuffer;
		const level = ctx.level;
		const chunksToStorage = ctx.chunksToStorage;
		const storage = ctx.storage;
		const sampleToChunkEnds = ctx.sampleToChunkEnds;
		const storageSizes = ctx.storageSizes;
		const methodsBuffer = ctx.methodsBuffer;
		const methodsBufferLongSamples = ctx.methodsBufferLongSamples;
		const methodsBufferDirectSamples = ctx.methodsBufferDirectSamples;

		const longSamplesChunksCount = ctx.longSamplesChunksCount;

		const levelPlusOne = level + 1;
		let children = 0;

		let fp = ctx.framesPointer;
		let methodsMapFirstPos = ctx.methodsMapFirstPos;

		for (let child = 0; child < longSamplesChunksCount; child++) {
			const storagePos = frames[fp++];
			const count = frames[fp++];
			const longSamplesBufferPos = frames[fp++];
			const size = storageSizes[storagePos];
			if (size === level) {
				for (let child = longSamplesBufferPos + count - 1; child >= longSamplesBufferPos; child--) {
					const sampleIndex = longSamplesBuffer[child];

					const chunkPos = (sampleToChunkEnds[sampleIndex - 1] || 0) + 1;

					const storagePos = chunksToStorage[chunkPos];
					const methodId = storage[storagePos + storageSizes[storagePos] - 1];

					if (methodsBuffer[methodId]++ === 0) {
						nextFrames[--methodsMapFirstPos] = methodId;
					}

					methodsBufferDirectSamples[methodId]++;
					children++;
				}
				continue;
			}
			const methodId = storage[storagePos + size - levelPlusOne];

			if ((methodsBuffer[methodId] += count) === count) {
				nextFrames[--methodsMapFirstPos] = methodId;
			}
			methodsBufferLongSamples[methodId]++;

			children++;
		}

		ctx.framesPointer = fp;
		ctx.methodsMapFirstPos = methodsMapFirstPos;

		return children;
	}

	function prepareDirectSamples(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const sampleToChunkPos = ctx.sampleToChunkPos;
		const sampleToStorageDelta = ctx.sampleToStorageDelta;
		const level = ctx.level;
		const chunksToStorage = ctx.chunksToStorage;
		const storage = ctx.storage;
		const methodsBuffer = ctx.methodsBuffer;
		const methodsBufferDirectSamples = ctx.methodsBufferDirectSamples;

		const directSamplesCount = ctx.directSamplesCount;

		let children = 0;

		let fp = ctx.framesPointer;
		let methodsMapFirstPos = ctx.methodsMapFirstPos;

		for (let child = 0; child < directSamplesCount; child++) {
			const sampleIndex = frames[fp++];
			const storageDelta = sampleToStorageDelta[sampleIndex] - level;
			if (storageDelta <= 0) {
				continue;
			}

			const chunkPos = sampleToChunkPos[sampleIndex];
			const storageStartPos = chunksToStorage[chunkPos];

			const storagePos = storageStartPos + storageDelta - 1;

			const methodId = storage[storagePos];

			if (methodsBuffer[methodId]++ === 0) {
				nextFrames[--methodsMapFirstPos] = methodId;
			}
			methodsBufferDirectSamples[methodId]++;

			children++;
		}

		ctx.framesPointer = fp;
		ctx.methodsMapFirstPos = methodsMapFirstPos;

		return children;
	}

	function prepareDirectSamplesDiff(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const sampleToChunkPos = ctx.sampleToChunkPos;
		const sampleToStorageDelta = ctx.sampleToStorageDelta;
		const level = ctx.level;
		const chunksToStorage = ctx.chunksToStorage;
		const storage = ctx.storage;
		const methodsBuffer = ctx.methodsBuffer;
		const methodsBufferDirectSamples = ctx.methodsBufferDirectSamples;

		const directSamplesCount = ctx.directSamplesCount;

		let children = 0;

		let fp = ctx.framesPointer;
		let methodsMapFirstPos = ctx.methodsMapFirstPos;

		for (let child = 0; child < directSamplesCount; child++) {
			const sampleIndex = frames[fp++];
			const storageDelta = (sampleToStorageDelta[sampleIndex] & 0x7fffffff) - level;
			if (storageDelta <= 0) {
				continue;
			}

			const chunkPos = sampleToChunkPos[sampleIndex]
			const storageStartPos = chunksToStorage[chunkPos];

			const storagePos = storageStartPos + storageDelta - 1;

			const methodId = storage[storagePos];

			if (methodsBuffer[methodId]++ === 0) {
				nextFrames[--methodsMapFirstPos] = methodId;
			}
			methodsBufferDirectSamples[methodId]++;

			children++;
		}

		ctx.framesPointer = fp;
		ctx.methodsMapFirstPos = methodsMapFirstPos;

		return children;
	}

	function prepareDirectSamplesReversed(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const sampleToChunkPos = ctx.sampleToChunkPos;
		const sampleToStorageDelta = ctx.sampleToStorageDelta;
		const level = ctx.level;
		const chunksToStorage = ctx.chunksToStorage;
		const storageSizes = ctx.storageSizes;
		const storage = ctx.storage;
		const methodsBuffer = ctx.methodsBuffer;
		const methodsBufferDirectSamples = ctx.methodsBufferDirectSamples;

		const directSamplesCount = ctx.directSamplesCount;

		let children = 0;

		let fp = ctx.framesPointer;
		let methodsMapFirstPos = ctx.methodsMapFirstPos;

		for (let child = 0; child < directSamplesCount; child++) {
			const sampleIndex = frames[fp++];
			const storageDelta = level - sampleToStorageDelta[sampleIndex];

			const chunkPos = sampleToChunkPos[sampleIndex];
			const storageStartPos = chunksToStorage[chunkPos];
			if (storageSizes[storageStartPos] <= storageDelta) {
				continue;
			}

			const methodId = storage[storageStartPos + storageDelta];

			if (methodsBuffer[methodId]++ === 0) {
				nextFrames[--methodsMapFirstPos] = methodId;
			}
			methodsBufferDirectSamples[methodId]++;

			children++;
		}

		ctx.framesPointer = fp;
		ctx.methodsMapFirstPos = methodsMapFirstPos;

		return children;
	}

	function prepareDirectSamplesReversedDiff(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const sampleToChunkPos = ctx.sampleToChunkPos;
		const sampleToStorageDelta = ctx.sampleToStorageDelta;
		const level = ctx.level;
		const chunksToStorage = ctx.chunksToStorage;
		const storageSizes = ctx.storageSizes;
		const storage = ctx.storage;
		const methodsBuffer = ctx.methodsBuffer;
		const methodsBufferDirectSamples = ctx.methodsBufferDirectSamples;

		const directSamplesCount = ctx.directSamplesCount;

		let children = 0;

		let fp = ctx.framesPointer;
		let methodsMapFirstPos = ctx.methodsMapFirstPos;

		for (let child = 0; child < directSamplesCount; child++) {
			const sampleIndex = frames[fp++];
			const storageDelta = level - (sampleToStorageDelta[sampleIndex] & 0x7fffffff);

			const chunkPos = sampleToChunkPos[sampleIndex];
			const storageStartPos = chunksToStorage[chunkPos];
			if (storageSizes[storageStartPos] <= storageDelta) {
				continue;
			}

			const methodId = storage[storageStartPos + storageDelta];

			if (methodsBuffer[methodId]++ === 0) {
				nextFrames[--methodsMapFirstPos] = methodId;
			}
			methodsBufferDirectSamples[methodId]++;

			children++;
		}

		ctx.framesPointer = fp;
		ctx.methodsMapFirstPos = methodsMapFirstPos;

		return children;
	}

	function prepareBaseDirectSamples(ctx) {
		const frames = ctx.frames;
		const sampleToChunkPos = ctx.sampleToChunkPos;
		const sampleToStorageDelta = ctx.sampleToStorageDelta;
		const level = ctx.level;
		const chunksToStorage = ctx.chunksToStorage;
		const storage = ctx.storage;
		const methodsBuffer = ctx.methodsBuffer;
		const baseMethodsBuffer = ctx.baseMethodsBuffer;
		const baseMethodsBufferDirectSamples = ctx.baseMethodsBufferDirectSamples;

		const baseDirectSamplesCount = ctx.baseDirectSamplesCount;

		let fp = ctx.framesPointer;

		for (let child = 0; child < baseDirectSamplesCount; child++) {
			const sampleIndex = frames[fp++];
			const storageDelta = (sampleToStorageDelta[sampleIndex] & 0x7fffffff) - level;
			if (storageDelta <= 0) {
				continue;
			}

			const chunkPos = sampleToChunkPos[sampleIndex];
			const storageStartPos = chunksToStorage[chunkPos];

			const storagePos = storageStartPos + storageDelta - 1;

			const methodId = storage[storagePos];

			if (methodsBuffer[methodId] !== 0) {
				baseMethodsBuffer[methodId]++;
				baseMethodsBufferDirectSamples[methodId]++;
			}
		}

		ctx.framesPointer = fp;
	}

	function prepareBaseDirectSamplesReversed(ctx) {
		const frames = ctx.frames;
		const sampleToChunkPos = ctx.sampleToChunkPos;
		const sampleToStorageDelta = ctx.sampleToStorageDelta;
		const level = ctx.level;
		const chunksToStorage = ctx.chunksToStorage;
		const storage = ctx.storage;
		const storageSizes = ctx.storageSizes;
		const methodsBuffer = ctx.methodsBuffer;
		const baseMethodsBuffer = ctx.baseMethodsBuffer;
		const baseMethodsBufferDirectSamples = ctx.baseMethodsBufferDirectSamples;

		const baseDirectSamplesCount = ctx.baseDirectSamplesCount;

		let fp = ctx.framesPointer;

		for (let child = 0; child < baseDirectSamplesCount; child++) {
			const sampleIndex = frames[fp++];
			const storageDelta = level - (sampleToStorageDelta[sampleIndex] & 0x7fffffff);

			const chunkPos = sampleToChunkPos[sampleIndex];
			const storageStartPos = chunksToStorage[chunkPos];
			if (storageSizes[storageStartPos] <= storageDelta) {
				continue;
			}

			const methodId = storage[storageStartPos + storageDelta];
			if (methodsBuffer[methodId] !== 0) {
				baseMethodsBuffer[methodId]++;
				baseMethodsBufferDirectSamples[methodId]++;
			}
		}

		ctx.framesPointer = fp;
	}

	function sortFramesForWrite(ctx) {
		const nextFrames = ctx.nextFrames;
		const methodsBuffer = ctx.methodsBuffer;
		const methodsMapFirstPos = ctx.methodsMapFirstPos;

		let maxCount = 0;
		for (let i = methodsMapFirstPos; i < nextFrames.length; i++) {
			maxCount = Math.max(maxCount, methodsBuffer[nextFrames[i]]);
		}

		sort(nextFrames, methodsMapFirstPos, nextFrames.length, methodsBuffer, 1 << (31 - Math.clz32(maxCount)));
	}

	function writeNextFrames(ctx) {
		const nextFrames = ctx.nextFrames;
		const methodsBuffer = ctx.methodsBuffer;
		const methodsBufferTheOnlyChunks = ctx.methodsBufferTheOnlyChunks;
		const methodsBufferLongSamples = ctx.methodsBufferLongSamples;
		const methodsBufferDirectSamples = ctx.methodsBufferDirectSamples;

		const methodsMapFirstPos = ctx.methodsMapFirstPos;

		let np = ctx.nextFramesPointer;
		let x = ctx.startX;

		for (let i = methodsMapFirstPos; i < nextFrames.length; i++) {
			const methodId = nextFrames[i];
			const count = methodsBuffer[methodId];
			const theOnlyChunksCountForMethod = methodsBufferTheOnlyChunks[methodId];
			const longSamplesChunksCountForMethod = methodsBufferLongSamples[methodId];
			const directSamplesCount = methodsBufferDirectSamples[methodId];

			nextFrames[np++] = methodId;
			nextFrames[np++] = x;
			nextFrames[np++] = count;
			nextFrames[np++] = theOnlyChunksCountForMethod;
			nextFrames[np++] = longSamplesChunksCountForMethod;
			nextFrames[np++] = directSamplesCount;

			x += count;
			methodsBufferTheOnlyChunks[methodId] = np;
			np += theOnlyChunksCountForMethod * 2;
			methodsBufferLongSamples[methodId] = np;
			np += longSamplesChunksCountForMethod * 3;
			methodsBufferDirectSamples[methodId] = np;
			np += directSamplesCount;
		}
	}

	function writeNextFramesReversed(ctx) {
		const nextFrames = ctx.nextFrames;
		const methodsBuffer = ctx.methodsBuffer;
		const methodsBufferTheOnlyChunks = ctx.methodsBufferTheOnlyChunks;
		const methodsBufferDirectSamples = ctx.methodsBufferDirectSamples;

		const methodsMapFirstPos = ctx.methodsMapFirstPos;

		let np = ctx.nextFramesPointer;
		let x = ctx.startX;

		for (let i = methodsMapFirstPos; i < nextFrames.length; i++) {
			const methodId = nextFrames[i];
			const count = methodsBuffer[methodId];
			const theOnlyChunksCountForMethod = methodsBufferTheOnlyChunks[methodId];
			const directSamplesCount = methodsBufferDirectSamples[methodId];

			nextFrames[np++] = methodId;
			nextFrames[np++] = x;
			nextFrames[np++] = count;
			nextFrames[np++] = theOnlyChunksCountForMethod;
			nextFrames[np++] = directSamplesCount;

			x += count;
			methodsBufferTheOnlyChunks[methodId] = np;
			np += theOnlyChunksCountForMethod * 2;
			methodsBufferDirectSamples[methodId] = np;
			np += directSamplesCount;
		}
	}

	function writeNextFramesDiff(ctx) {
		const nextFrames = ctx.nextFrames;
		const methodsBuffer = ctx.methodsBuffer;
		const methodsBufferTheOnlyChunks = ctx.methodsBufferTheOnlyChunks;
		const methodsBufferDirectSamples = ctx.methodsBufferDirectSamples;
		const baseMethodsBuffer = ctx.baseMethodsBuffer;
		const baseMethodsBufferTheOnlyChunks = ctx.baseMethodsBufferTheOnlyChunks;
		const baseMethodsBufferDirectSamples = ctx.baseMethodsBufferDirectSamples;

		const methodsMapFirstPos = ctx.methodsMapFirstPos;

		let np = ctx.nextFramesPointer;
		let x = ctx.startX;

		for (let i = methodsMapFirstPos; i < nextFrames.length; i++) {
			const methodId = nextFrames[i];
			const count = methodsBuffer[methodId];
			const theOnlyChunksCount = methodsBufferTheOnlyChunks[methodId];
			const directSamplesCount = methodsBufferDirectSamples[methodId];

			const baseCount = baseMethodsBuffer[methodId];
			const baseTheOnlyChunksCount = baseMethodsBufferTheOnlyChunks[methodId];
			const baseDirectSamplesCount = baseMethodsBufferDirectSamples[methodId];

			nextFrames[np++] = methodId;
			nextFrames[np++] = x;

			nextFrames[np++] = count;
			nextFrames[np++] = theOnlyChunksCount;
			nextFrames[np++] = directSamplesCount;

			nextFrames[np++] = baseCount;
			nextFrames[np++] = baseTheOnlyChunksCount;
			nextFrames[np++] = baseDirectSamplesCount;

			x += count;

			methodsBufferTheOnlyChunks[methodId] = np;
			np += theOnlyChunksCount * 2;

			methodsBufferDirectSamples[methodId] = np;
			np += directSamplesCount;

			baseMethodsBufferTheOnlyChunks[methodId] = np;
			np += baseTheOnlyChunksCount * 2;

			baseMethodsBufferDirectSamples[methodId] = np;
			np += baseDirectSamplesCount;
		}
	}

	function splitTheOnlyChunks(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const level = ctx.level;
		const storage = ctx.storage;
		const storageSizes = ctx.storageSizes;
		const methodsBufferTheOnlyChunks = ctx.methodsBufferTheOnlyChunks;

		const theOnlyChunksCount = ctx.theOnlyChunksCount;
		const levelPlusOne = level + 1;

		let fp = ctx.framesPointer;
		for (let child = 0; child < theOnlyChunksCount; child++) {
			const storagePos = frames[fp++];
			const count = frames[fp++];
			const size = storageSizes[storagePos];
			if (size === level) {
				continue;
			}

			const methodId = storage[storagePos + size - levelPlusOne];

			nextFrames[methodsBufferTheOnlyChunks[methodId]++] = storagePos;
			nextFrames[methodsBufferTheOnlyChunks[methodId]++] = count;
		}
		ctx.framesPointer = fp;
	}

	function splitTheOnlyChunksReversed(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const level = ctx.level;
		const storage = ctx.storage;
		const storageSizes = ctx.storageSizes;
		const methodsBufferTheOnlyChunks = ctx.methodsBufferTheOnlyChunks;

		const theOnlyChunksCount = ctx.theOnlyChunksCount;

		let fp = ctx.framesPointer;
		for (let child = 0; child < theOnlyChunksCount; child++) {
			const storagePos = frames[fp++];
			const count = frames[fp++];
			const size = storageSizes[storagePos];
			if (size === level) {
				continue;
			}

			const methodId = storage[storagePos + level];

			nextFrames[methodsBufferTheOnlyChunks[methodId]++] = storagePos;
			nextFrames[methodsBufferTheOnlyChunks[methodId]++] = count;
		}
		ctx.framesPointer = fp;
	}

	function splitBaseTheOnlyChunks(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const level = ctx.level;
		const storage = ctx.storage;
		const storageSizes = ctx.storageSizes;
		const methodsBuffer = ctx.methodsBuffer;
		const baseMethodsBufferTheOnlyChunks = ctx.baseMethodsBufferTheOnlyChunks;

		const baseTheOnlyChunksCount = ctx.baseTheOnlyChunksCount;
		const levelPlusOne = level + 1;

		let fp = ctx.framesPointer;
		for (let child = 0; child < baseTheOnlyChunksCount; child++) {
			const storagePos = frames[fp++];
			const count = frames[fp++];
			const size = storageSizes[storagePos];
			if (size === level) {
				continue;
			}

			const methodId = storage[storagePos + size - levelPlusOne];

			if (methodsBuffer[methodId] !== 0) {
				nextFrames[baseMethodsBufferTheOnlyChunks[methodId]++] = storagePos;
				nextFrames[baseMethodsBufferTheOnlyChunks[methodId]++] = count;
			}
		}
		ctx.framesPointer = fp;
	}

	function splitBaseTheOnlyChunksReversed(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const level = ctx.level;
		const storage = ctx.storage;
		const storageSizes = ctx.storageSizes;
		const methodsBuffer = ctx.methodsBuffer;
		const baseMethodsBufferTheOnlyChunks = ctx.baseMethodsBufferTheOnlyChunks;

		const baseTheOnlyChunksCount = ctx.baseTheOnlyChunksCount;

		let fp = ctx.framesPointer;
		for (let child = 0; child < baseTheOnlyChunksCount; child++) {
			const storagePos = frames[fp++];
			const count = frames[fp++];
			const size = storageSizes[storagePos];
			if (size === level) {
				continue;
			}

			const methodId = storage[storagePos + level];

			if (methodsBuffer[methodId] !== 0) {
				nextFrames[baseMethodsBufferTheOnlyChunks[methodId]++] = storagePos;
				nextFrames[baseMethodsBufferTheOnlyChunks[methodId]++] = count;
			}
		}
		ctx.framesPointer = fp;
	}

	function splitLongSamplesChunks(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const sampleToChunkPos = ctx.sampleToChunkPos;
		const sampleToStorageDelta = ctx.sampleToStorageDelta;
		const longSamplesBuffer = ctx.longSamplesBuffer;
		const level = ctx.level;
		const chunksToStorage = ctx.chunksToStorage;
		const storage = ctx.storage;
		const sampleToChunkEnds = ctx.sampleToChunkEnds;
		const storageSizes = ctx.storageSizes;
		const methodsBufferLongSamples = ctx.methodsBufferLongSamples;
		const methodsBufferDirectSamples = ctx.methodsBufferDirectSamples;

		const longSamplesChunksCount = ctx.longSamplesChunksCount;

		const levelPlusOne = level + 1;

		let fp = ctx.framesPointer;
		for (let child = 0; child < longSamplesChunksCount; child++) {
			const storagePos = frames[fp++];
			const count = frames[fp++];
			const longSamplesBufferPos = frames[fp++];
			const size = storageSizes[storagePos];
			if (size === level) {
				for (let child = longSamplesBufferPos + count - 1; child >= longSamplesBufferPos; child--) {
					const sampleIndex = longSamplesBuffer[child];

					let chunkPos = (sampleToChunkEnds[sampleIndex - 1] || 0) + 1;
					const storagePos = chunksToStorage[chunkPos];
					const storageSize = storageSizes[storagePos];
					sampleToChunkPos[sampleIndex] = chunkPos;
					sampleToStorageDelta[sampleIndex] = storageSize + levelPlusOne;
					let storageDelta = sampleToStorageDelta[sampleIndex] - levelPlusOne;
					if (storageDelta === 1) {
						const chunkEnd = sampleToChunkEnds[sampleIndex] || chunksToStorage.length;
						if (++chunkPos !== chunkEnd) {
							sampleToChunkPos[sampleIndex] = chunkPos;
							const storagePos = chunksToStorage[chunkPos];
							storageDelta = storageSizes[storagePos];
							sampleToStorageDelta[sampleIndex] = storageDelta + levelPlusOne;
						}
					}

					const methodId = storage[storagePos + storageSize - 1];

					nextFrames[methodsBufferDirectSamples[methodId]++] = sampleIndex;
				}
				continue;
			}

			const methodId = storage[storagePos + size - levelPlusOne];

			nextFrames[methodsBufferLongSamples[methodId]++] = storagePos;
			nextFrames[methodsBufferLongSamples[methodId]++] = count;
			nextFrames[methodsBufferLongSamples[methodId]++] = longSamplesBufferPos;
		}
		ctx.framesPointer = fp;
	}

	function splitDirectSamples(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const sampleToChunkPos = ctx.sampleToChunkPos;
		const sampleToStorageDelta = ctx.sampleToStorageDelta;
		const level = ctx.level;
		const chunksToStorage = ctx.chunksToStorage;
		const storage = ctx.storage;
		const sampleToChunkEnds = ctx.sampleToChunkEnds;
		const storageSizes = ctx.storageSizes;
		const methodsBufferDirectSamples = ctx.methodsBufferDirectSamples;

		const directSamplesCount = ctx.directSamplesCount;

		const levelPlusOne = level + 1;

		let fp = ctx.framesPointer;
		for (let child = 0; child < directSamplesCount; child++) {
			const sampleIndex = frames[fp++];
			let storageDelta = sampleToStorageDelta[sampleIndex] - level;
			if (storageDelta <= 0) {
				continue;
			}
			let chunkPos = sampleToChunkPos[sampleIndex];
			const storageStartPos = chunksToStorage[chunkPos];

			const storagePos = storageStartPos + storageDelta - 1;

			if (storageDelta === 1) {
				const chunkEnd = sampleToChunkEnds[sampleIndex] || chunksToStorage.length;
				if (++chunkPos !== chunkEnd) {
					sampleToChunkPos[sampleIndex] = chunkPos;
					const storagePos = chunksToStorage[chunkPos];
					storageDelta = storageSizes[storagePos];
					sampleToStorageDelta[sampleIndex] = storageDelta + levelPlusOne;
				}
			}

			const methodId = storage[storagePos];

			nextFrames[methodsBufferDirectSamples[methodId]++] = sampleIndex;
		}
		ctx.framesPointer = fp;
	}

	function splitDirectSamplesDiff(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const level = ctx.level;
		const storage = ctx.storage;
		const storageSizes = ctx.storageSizes;
		const sampleToStorageDelta = ctx.sampleToStorageDelta;
		const sampleToChunkPos = ctx.sampleToChunkPos;
		const chunksToStorage = ctx.chunksToStorage;
		const sampleToChunkEnds = ctx.sampleToChunkEnds;
		const methodsBufferDirectSamples = ctx.methodsBufferDirectSamples;

		const directSamplesCount = ctx.directSamplesCount;
		const levelPlusOne = level + 1;

		let fp = ctx.framesPointer;

		for (let child = 0; child < directSamplesCount; child++) {
			const sampleIndex = frames[fp++];
			let storageDelta = (sampleToStorageDelta[sampleIndex] & 0x7fffffff) - level;
			if (storageDelta <= 0) {
				sampleToStorageDelta[sampleIndex] = 0;
				continue;
			}
			let chunkPos = sampleToChunkPos[sampleIndex];
			const storageStartPos = chunksToStorage[chunkPos];

			const storagePos = storageStartPos + storageDelta - 1;

			if (storageDelta === 1) {
				const chunkEnd = sampleToChunkEnds[sampleIndex] || chunksToStorage.length;
				if (++chunkPos !== chunkEnd) {
					sampleToChunkPos[sampleIndex] = chunkPos;
					const storagePos = chunksToStorage[chunkPos];
					storageDelta = storageSizes[storagePos];
					sampleToStorageDelta[sampleIndex] = (storageDelta + levelPlusOne) | 0x80000000;
				}
			}

			const methodId = storage[storagePos];

			nextFrames[methodsBufferDirectSamples[methodId]++] = sampleIndex;
		}
		ctx.framesPointer = fp;
	}

	function splitDirectSamplesReversed(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const sampleToChunkPos = ctx.sampleToChunkPos;
		const sampleToStorageDelta = ctx.sampleToStorageDelta;
		const level = ctx.level;
		const chunksToStorage = ctx.chunksToStorage;
		const storage = ctx.storage;
		const sampleToChunkEnds = ctx.sampleToChunkEnds;
		const storageSizes = ctx.storageSizes;
		const methodsBufferDirectSamples = ctx.methodsBufferDirectSamples;

		const directSamplesCount = ctx.directSamplesCount;

		const levelPlusOne = level + 1;

		let fp = ctx.framesPointer;
		for (let child = 0; child < directSamplesCount; child++) {
			const sampleIndex = frames[fp++];
			const storageDelta = level - sampleToStorageDelta[sampleIndex];

			let chunkPos = sampleToChunkPos[sampleIndex];
			const storageStartPos = chunksToStorage[chunkPos];
			const storageSize = storageSizes[storageStartPos];
			if (storageSize <= storageDelta) {
				continue;
			}

			const storagePos = storageStartPos + storageDelta;

			if (storageDelta + 1 === storageSize) {
				const chunkStart = sampleToChunkEnds[sampleIndex - 1] || 0;
				if (--chunkPos >= chunkStart) {
					sampleToChunkPos[sampleIndex] = chunkPos;
					sampleToStorageDelta[sampleIndex] = levelPlusOne;
				}
			}

			const methodId = storage[storagePos];

			nextFrames[methodsBufferDirectSamples[methodId]++] = sampleIndex;
		}
		ctx.framesPointer = fp;
	}

	function splitDirectSamplesReversedDiff(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const level = ctx.level;
		const storage = ctx.storage;
		const storageSizes = ctx.storageSizes;
		const sampleToStorageDelta = ctx.sampleToStorageDelta;
		const sampleToChunkPos = ctx.sampleToChunkPos;
		const chunksToStorage = ctx.chunksToStorage;
		const sampleToChunkEnds = ctx.sampleToChunkEnds;
		const methodsBufferDirectSamples = ctx.methodsBufferDirectSamples;

		const directSamplesCount = ctx.directSamplesCount;
		const levelPlusOne = level + 1;

		let fp = ctx.framesPointer;

		for (let child = 0; child < directSamplesCount; child++) {
			const sampleIndex = frames[fp++];
			const delta = sampleToStorageDelta[sampleIndex] & 0x7fffffff;
			const storageDelta = level - delta;

			let chunkPos = sampleToChunkPos[sampleIndex];
			const storageStartPos = chunksToStorage[chunkPos];
			const storageSize = storageSizes[storageStartPos];
			if (storageSize <= storageDelta) {
				sampleToStorageDelta[sampleIndex] = delta;
				continue;
			}

			const storagePos = storageStartPos + storageDelta;

			if (storageDelta + 1 === storageSize) {
				const chunkStart = sampleToChunkEnds[sampleIndex - 1] || 0;
				if (--chunkPos >= chunkStart) {
					sampleToChunkPos[sampleIndex] = chunkPos;
					sampleToStorageDelta[sampleIndex] = levelPlusOne | 0x80000000;
				}
			}

			const methodId = storage[storagePos];

			nextFrames[methodsBufferDirectSamples[methodId]++] = sampleIndex;
		}
		ctx.framesPointer = fp;
	}

	function splitBaseDirectSamples(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const sampleToChunkPos = ctx.sampleToChunkPos;
		const sampleToStorageDelta = ctx.sampleToStorageDelta;
		const level = ctx.level;
		const chunksToStorage = ctx.chunksToStorage;
		const storage = ctx.storage;
		const sampleToChunkEnds = ctx.sampleToChunkEnds;
		const storageSizes = ctx.storageSizes;
		const methodsBuffer = ctx.methodsBuffer;
		const baseMethodsBufferDirectSamples = ctx.baseMethodsBufferDirectSamples;

		const baseDirectSamplesCount = ctx.baseDirectSamplesCount;

		const levelPlusOne = level + 1;

		let fp = ctx.framesPointer;

		for (let child = 0; child < baseDirectSamplesCount; child++) {
			const sampleIndex = frames[fp++];
			const baseStorageDelta = sampleToStorageDelta[sampleIndex];
			let storageDelta = (baseStorageDelta & 0x7fffffff) - level;
			if (storageDelta <= 0) {
				continue;
			}

			let chunkPos = sampleToChunkPos[sampleIndex];
			const storageStartPos = chunksToStorage[chunkPos];

			const storagePos = storageStartPos + storageDelta - 1;

			if (storageDelta === 1 &&
				// will be done for this sample by not-based step
				(baseStorageDelta & 0x80000000) === 0) {
				const chunkEnd = sampleToChunkEnds[sampleIndex] || chunksToStorage.length;
				if (++chunkPos !== chunkEnd) {
					sampleToChunkPos[sampleIndex] = chunkPos;
					const storagePos = chunksToStorage[chunkPos];
					storageDelta = storageSizes[storagePos];
					sampleToStorageDelta[sampleIndex] = storageDelta + levelPlusOne;
				}
			}

			const methodId = storage[storagePos];

			if (methodsBuffer[methodId] !== 0) {
				nextFrames[baseMethodsBufferDirectSamples[methodId]++] = sampleIndex;
			}
		}
		ctx.framesPointer = fp;
	}

	function splitBaseDirectSamplesReversed(ctx) {
		const frames = ctx.frames;
		const nextFrames = ctx.nextFrames;
		const sampleToChunkPos = ctx.sampleToChunkPos;
		const sampleToStorageDelta = ctx.sampleToStorageDelta;
		const level = ctx.level;
		const chunksToStorage = ctx.chunksToStorage;
		const storage = ctx.storage;
		const sampleToChunkEnds = ctx.sampleToChunkEnds;
		const storageSizes = ctx.storageSizes;
		const methodsBuffer = ctx.methodsBuffer;
		const baseMethodsBufferDirectSamples = ctx.baseMethodsBufferDirectSamples;

		const baseDirectSamplesCount = ctx.baseDirectSamplesCount;

		const levelPlusOne = level + 1;

		let fp = ctx.framesPointer;

		for (let child = 0; child < baseDirectSamplesCount; child++) {
			const sampleIndex = frames[fp++];
			const baseStorageDelta = sampleToStorageDelta[sampleIndex];
			const storageDelta = level - (baseStorageDelta & 0x7fffffff);

			let chunkPos = sampleToChunkPos[sampleIndex];
			const storageStartPos = chunksToStorage[chunkPos];
			const storageSize = storageSizes[storageStartPos];
			if (storageSize <= storageDelta) {
				continue;
			}

			const storagePos = storageStartPos + storageDelta;

			if (storageDelta + 1 === storageSize &&
				// will be done for this sample by not-based step
				(baseStorageDelta & 0x80000000) === 0) {
				const chunkStart = sampleToChunkEnds[sampleIndex - 1] || 0;
				if (--chunkPos >= chunkStart) {
					sampleToChunkPos[sampleIndex] = chunkPos;
					sampleToStorageDelta[sampleIndex] = levelPlusOne;
				}
			}

			const methodId = storage[storagePos];

			if (methodsBuffer[methodId] !== 0) {
				nextFrames[baseMethodsBufferDirectSamples[methodId]++] = sampleIndex;
			}
		}
		ctx.framesPointer = fp;
	}

	function cleanupMethodBuffers(ctx) {
		const nextFrames = ctx.nextFrames;
		const methodsBuffer = ctx.methodsBuffer;
		const methodsBufferTheOnlyChunks = ctx.methodsBufferTheOnlyChunks;
		const methodsBufferLongSamples = ctx.methodsBufferLongSamples;
		const methodsBufferDirectSamples = ctx.methodsBufferDirectSamples;

		let np = ctx.nextFramesPointer;
		let methodsMapFirstPos = ctx.methodsMapFirstPos;
		for (let i = methodsMapFirstPos; i < nextFrames.length; i++) {
			const methodId = nextFrames[np];

			methodsBuffer[methodId] = 0;
			methodsBufferTheOnlyChunks[methodId] = 0;
			methodsBufferLongSamples[methodId] = 0;
			methodsBufferDirectSamples[methodId] = 0;

			np += nextFrames[np + 3] * 2 + nextFrames[np + 4] * 3 + nextFrames[np + 5] + 6;
		}
		ctx.nextFramesPointer = np;
	}

	function cleanupMethodBuffersReversed(ctx) {
		const nextFrames = ctx.nextFrames;
		const methodsBuffer = ctx.methodsBuffer;
		const methodsBufferTheOnlyChunks = ctx.methodsBufferTheOnlyChunks;
		const methodsBufferDirectSamples = ctx.methodsBufferDirectSamples;

		let np = ctx.nextFramesPointer;
		let methodsMapFirstPos = ctx.methodsMapFirstPos;
		for (let i = methodsMapFirstPos; i < nextFrames.length; i++) {
			const methodId = nextFrames[np];

			methodsBuffer[methodId] = 0;
			methodsBufferTheOnlyChunks[methodId] = 0;
			methodsBufferDirectSamples[methodId] = 0;

			np += nextFrames[np + 3] * 2 + nextFrames[np + 4] + 5;
		}
		ctx.nextFramesPointer = np;
	}

	function cleanupMethodBuffersDiff(ctx) {
		const nextFrames = ctx.nextFrames;
		const methodsBuffer = ctx.methodsBuffer;
		const methodsBufferTheOnlyChunks = ctx.methodsBufferTheOnlyChunks;
		const methodsBufferDirectSamples = ctx.methodsBufferDirectSamples;
		const baseMethodsBuffer = ctx.baseMethodsBuffer;
		const baseMethodsBufferTheOnlyChunks = ctx.baseMethodsBufferTheOnlyChunks;
		const baseMethodsBufferDirectSamples = ctx.baseMethodsBufferDirectSamples;

		let np = ctx.nextFramesPointer;
		let methodsMapFirstPos = ctx.methodsMapFirstPos;
		for (let i = methodsMapFirstPos; i < nextFrames.length; i++) {
			const methodId = nextFrames[np];

			methodsBuffer[methodId] = 0;
			methodsBufferTheOnlyChunks[methodId] = 0;
			methodsBufferDirectSamples[methodId] = 0;

			baseMethodsBuffer[methodId] = 0;
			baseMethodsBufferTheOnlyChunks[methodId] = 0;
			baseMethodsBufferDirectSamples[methodId] = 0;

			np += (nextFrames[np + 3] + nextFrames[np + 6]) * 2 + (nextFrames[np + 4] + nextFrames[np + 7]) + 8;
		}
		ctx.nextFramesPointer = np;
	}

	function renderWithMatch(newCanvasHeight, root, level, minLevel) {
		newCanvasHeight = Math.min(16384 / (devicePixelRatio || 1), newCanvasHeight) | 0;
		if (canvasHeight !== newCanvasHeight) {
			canvasHeight = newCanvasHeight;
			canvas.style.height = canvasHeight + 'px';
			canvas.height = canvasHeight * (devicePixelRatio || 1);
			c = canvas.getContext('2d');
			if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
			c.font = document.body.style.font;
		}
		const matched = render(root, level, minLevel);
		displayMatched(matched);
	}

	function redrawHeatSamplesImpl(from, to, dx) {
		const startBlock = currentHeatmap.startBlock();

		const scale = currentHeatmap.timeSquareScale;
		const max = currentHeatmap.max(showFound);
		const min = currentHeatmap.min(showFound);
		const delta = Math.max(1, max - min);
		const counts = showFound ? currentHeatmap.blocksData.foundCounts : currentHeatmap.blocksData.counts;

		const r = showFound ? dRs : dR;
		const g = showFound ? dGs : dG;
		const b = showFound ? dBs : dB;

		for (let index = from; index <= to; index++) {
			let color;
			const firstCountsIndex = (index - startBlock) * scale;
			const afterLastCountsIndex = firstCountsIndex + scale;
			if (afterLastCountsIndex <= 0 || firstCountsIndex >= counts.length) {
				color = '#ddd';
			} else {
				const countBeforeFirstBlock = getCount(counts, firstCountsIndex - 1);
				const countAtLastBlock = getCount(counts, afterLastCountsIndex - 1);
				const count = countAtLastBlock - countBeforeFirstBlock;
				if (count === 0) {
					color = '#fff';
				} else {
					let ratio = Math.max(0, (count - min) / delta);
					const ratioM = (ratio * 192 + 24) | 0;

					const C = 255 - Math.abs(255 - (ratioM << 1));
					const m = (255 - ratioM) - (C >> 1);
					color = 'rgb(' + (((r * C) >> 8) + m) + ',' + (((g * C) >> 8) + m) + ',' + (((b * C) >> 8) + m) + ')';
				}
			}
			heatC.fillStyle = color;

			let x = Math.floor(index / currentHeatmap.timeSquareRowsCount);
			let y = index % currentHeatmap.timeSquareRowsCount;
			heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
		}

		let fromBlock = Math.floor(from / currentHeatmap.squaresBetweenMarks / currentHeatmap.timeSquareRowsCount) - 1;
		let toBlock = Math.ceil(to / currentHeatmap.squaresBetweenMarks / currentHeatmap.timeSquareRowsCount);

		let markPixels = currentHeatmap.squaresBetweenMarks * sq;

		heatC.fillStyle = '#fff';
		heatC.fillRect(
			fromBlock * markPixels - dx,
			0,
			(toBlock - fromBlock + 1) * markPixels,
			canvasTimeHeight
		);

		heatC.beginPath();
		heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
		heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
		heatC.stroke();

		heatC.fillStyle = '#000';

		let groupSize = currentHeatmap.timeSquareRowsCount;
		let oneBlockMs = currentHeatmap.currentTimeSquareMs();
		let oneGroupMs = oneBlockMs * groupSize;
		let oneMarkMs = oneGroupMs * currentHeatmap.squaresBetweenMarks;
		for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
			let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
			let ms = origin + markIndex * oneMarkMs;
			let markOffset = markIndex * markPixels - dx;

			let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);
			let x = markOffset + 4;
			heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

			heatC.beginPath();
			heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
			heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
			heatC.stroke();
		}
	}

	function redrawHeatSamples(from, to) {
		let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

		from = Math.max(from, currentHeatmap.timeSquareRowsCount * Math.floor(dx / sq));
		to = Math.min(to, currentHeatmap.timeSquareRowsCount * Math.ceil((dx + heatCanvas.width) / sq));
		redrawHeatSamplesImpl(from, to, dx);
	}

	function redrawHeatMap() {
		redrawHeatSamples(0, (1 + currentHeatmap.count() / currentHeatmap.timeSquareRowsCount | 0) * currentHeatmap.timeSquareRowsCount);
	}

	function fillCanvasWithEvents(zoom) {
		currentHeatmap.setZoom(zoom);

		const m = devicePixelRatio || 1;
		sqScale = m;
		sqPx = 5;
		sq = Math.floor(sqPx * m);
		sqPx = sq / m;
		canvasTimeHeight = sq * 2 + 2;
		canvasTimeHeightPx = canvasTimeHeight / m;

		const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
		const heightPx = sqPx * currentHeatmap.timeSquareRowsCount + canvasTimeHeightPx;

		const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / currentHeatmap.timeSquareRowsCount)) * sqPx;
		heatCanvasWrapper.style.width = heatWidthPx + 'px';
		if (heatCanvasContainer.offsetWidth > heatWidthPx) {
			heatCanvasContainer.style.overflowX = 'hidden';
		} else {
			heatCanvasContainer.style.overflowX = 'scroll';
		}

		heatCanvas.width = Math.ceil(widthPx * m);
		heatCanvas.height = Math.ceil(heightPx * m);
		heatCanvas.style.width = widthPx + 'px';
		heatCanvas.style.height = heightPx + 'px';

		heatC = heatCanvas.getContext('2d');
		heatC.font = sq * 2 + 'px Verdana, sans-serif';
		heatC.lineWidth = 1;
		heatC.strokeStyle = '#000';

		document.getElementById('heatmap-height-line').textContent = zoomToText[currentHeatmap.zoom];
		redrawHeatMap();
	}

	function search(r, filter) {
		filter = filter || false;
		if (r && (r = prompt('Enter regexp to ' + (filter ? 'filter' : 'search') + ':', '')) === null) {
			return;
		}
		const wasFilter = filterFrames;
		filterFrames = filter;
		if (!r) {
			showFound = false;
			pattern = undefined;
			redrawHeatMap();
			if (wasFilter === filterFrames) {
				searchOnFlame();
			} else {
				reselect();
			}
			return;
		}

		const regex = RegExp(r)
		pattern = method => regex.test(methods.n[method]);
		showFound = true;
		const matchedMethods = new Set();
		for (let index = methods.c.length - 1; index >= 0; index--) {
			if (regex.test(methods.n[index])) {
				matchedMethods.add(index);
			}
		}

		const storage = currentHeatmap.blocksData.storage;
		const storageSizes = currentHeatmap.blocksData.storageSizes;
		const marks = currentHeatmap.blocksData.marks;
		marks.fill(0);
		for (let storagePos = storage.length - 1; storagePos >= 0;) {
			if (matchedMethods.has(storage[storagePos])) {
				marks[storagePos >> 5] |= 1 << (storagePos & 31);
				storagePos--;
				while (storagePos >= 0 && storageSizes[storagePos] !== 1) {
					marks[storagePos >> 5] |= 1 << (storagePos & 31);
					storagePos--;
				}
			} else {
				storagePos--;
			}
		}

		searchForMarks();
		if (filterFrames || wasFilter) {
			reselect();
		} else {
			searchOnFlame();
		}
	}

	function searchForMethod(methodId) {
		showFound = true;
		pattern = function (method) {
			return method === methodId;
		}
		const storage = currentHeatmap.blocksData.storage;
		const storageSizes = currentHeatmap.blocksData.storageSizes;
		const marks = currentHeatmap.blocksData.marks;
		marks.fill(0);
		for (let storagePos = storage.length - 1; storagePos >= 0;) {
			if (storage[storagePos] === methodId) {
				marks[storagePos >> 5] |= 1 << (storagePos & 31);
				storagePos--;
				while (storagePos >= 0 && storageSizes[storagePos] !== 1) {
					marks[storagePos >> 5] |= 1 << (storagePos & 31);
					storagePos--;
				}
			} else {
				storagePos--;
			}
		}

		searchForMarks();
		searchOnFlame();
	}

	function searchOnFlame() {
		const matched = render(root, rootLevel);
		displayMatched(matched);
	}

	function displayMatched(matched) {
		if (showFound) {
			document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
			document.getElementById('match').style.display = 'inline-block';
			document.getElementById('produced').style.display = 'none';
		} else {
			document.getElementById('match').style.display = 'none';
			document.getElementById('produced').style.display = 'inherit';
		}
	}

	function searchForMarks() {
		const found = currentHeatmap.blocksData.foundCounts;
		const maxCounts = currentHeatmap.blocksData.searchMaxCounts;
		const minCounts = currentHeatmap.blocksData.searchMinCounts;

		searchForMarksStep();
		calculateMinMax(found, minCounts, maxCounts);
		redrawHeatMap();
	}

	function searchForMarksStep() {
		const counts = currentHeatmap.blocksData.counts;
		const chunksToStorage = currentHeatmap.blocksData.chunksToStorage;
		const sampleToChunkEnds = currentHeatmap.blocksData.sampleToChunkEnds;
		const found = currentHeatmap.blocksData.foundCounts;
		const marks = currentHeatmap.blocksData.marks;
		const sampleMarks = currentHeatmap.blocksData.sampleMarks;

		sampleMarks.fill(0);
		let sample = 0;
		let chunk = 0;
		let foundCount = 0;
		for (let block = 0; block < counts.length; block++) {
			const count = counts[block];
			for (; sample < count; sample++) {
				const chunkEnd = sampleToChunkEnds[sample];
				for (; chunk < chunkEnd; chunk++) {
					const storagePos = chunksToStorage[chunk];
					if ((marks[storagePos >> 5] & (1 << (storagePos & 31))) !== 0) {
						sampleMarks[sample >> 5] |= 1 << (sample & 31);
						foundCount++;
						chunk = chunkEnd;
						break;
					}
				}
			}
			found[block] = foundCount;
		}
	}

	function calculateMinMax(counts, minCounts, maxCounts) {
		for (let zi = 0; zi < zoomToGroupSize.length; zi++) {
			const z = zoomToGroupSize[zi];
			let max = 0;
			let min = 0x7fffffff;
			let prev = 0;
			for (let i = z - 1; i < counts.length; i += z) {
				const f = counts[i];
				const diff = f - prev;
				if (diff !== 0) {
					max = Math.max(max, diff);
					min = Math.min(min, diff);
				}
				prev = f;
			}
			const diff = counts[counts.length - 1] - prev;
			max = Math.max(max, diff);
			min = Math.min(min, max);
			maxCounts[zi] = max;
			minCounts[zi] = min;
		}
	}

	function calculateInitialZoom() {
		const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

		let z = 0;
		for (; z < zoomToGroupSize.length - 1; z++) {
			if (currentHeatmap.blocksData.counts.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
				break;
			}
		}
		return z;
	}

	function renderHeatmap() {
		let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
		heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

		fillCanvasWithEvents(calculateInitialZoom());

		renderWrapper(0, currentHeatmap.blocksData.counts.length - 1);
	}

	heatCanvasContainer.addEventListener('scroll', function () {
		let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
		let dxPx = dx / sqScale;
		heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
		let delta = Math.abs(dx - prevDx);
		if (delta >= heatCanvas.width) {
			redrawHeatMap();
		} else {
			heatC.drawImage(heatCanvas, prevDx - dx, 0);
			if (prevDx < dx) {
				let from = currentHeatmap.timeSquareRowsCount * Math.floor((prevDx + heatCanvas.width) / sq);
				let to = currentHeatmap.timeSquareRowsCount * Math.ceil((dx + heatCanvas.width) / sq);
				redrawHeatSamplesImpl(from, to, dx);
			} else {
				let from = currentHeatmap.timeSquareRowsCount * Math.floor(dx / sq);
				let to = currentHeatmap.timeSquareRowsCount * Math.ceil(prevDx / sq);
				redrawHeatSamplesImpl(from, to, dx);
			}
		}
		prevDx = dx;
		cooldownTime = performance.now() + 500;
	});

	document.getElementById('heatmap-height-line').onclick = function () {
		fillCanvasWithEvents((zoomToGroupSize.length + currentHeatmap.zoom - 1) % (zoomToGroupSize.length));
		highlightStart = highlightEnd = heatDiffSample1 = heatDiffSample2 = heatActiveSample1 = heatActiveSample2 = -1;
		for (let suffix of ['Selection', 'Diff', 'Active']) {
			for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
				document.getElementById(prefix + suffix).style.display = 'none';
			}
		}
	}

	function callHighlightRedraw(start, end, suffix) {
		let left = document.getElementById('left' + suffix);
		let leftMiddle = document.getElementById('leftMiddle' + suffix);
		let middle = document.getElementById('middle' + suffix);
		let rightMiddle = document.getElementById('rightMiddle' + suffix);
		let right = document.getElementById('right' + suffix);

		let x1 = Math.floor(start / currentHeatmap.timeSquareRowsCount);
		let y1 = start % currentHeatmap.timeSquareRowsCount;
		let x2 = Math.floor(end / currentHeatmap.timeSquareRowsCount);
		let y2 = end % currentHeatmap.timeSquareRowsCount;

		let veryStartX = x1 * sqPx;
		let veryStartY = y1 * sqPx;
		let veryEndX = x2 * sqPx;
		let px = 1 / sqScale;
		let singleElementWidth = sqPx + px;

		let topPadding = canvasTimeHeightPx;

		if (x1 === x2) {
			left.style.display = 'none';
			right.style.display = 'none';

			for (let b of [middle, leftMiddle, rightMiddle]) {
				b.style.left = veryStartX + 'px';
				b.style.top = topPadding + veryStartY + 'px';
				b.style.width = singleElementWidth + 'px';
				b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
				b.style.display = 'block';
			}
		} else {
			left.style.left = veryStartX + 'px';
			left.style.top = topPadding + veryStartY + 'px';
			left.style.width = singleElementWidth + 'px';
			left.style.height = (currentHeatmap.timeSquareRowsCount - y1) * sqPx + px + 'px';
			left.style.display = 'block';

			leftMiddle.style.left = veryStartX + 'px';
			leftMiddle.style.top = topPadding + 'px';
			leftMiddle.style.width = singleElementWidth + 'px';
			leftMiddle.style.height = y1 * sqPx + px + 'px';
			leftMiddle.style.display = 'block';

			rightMiddle.style.left = veryEndX + 'px';
			rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
			rightMiddle.style.width = sqPx + px + 'px';
			rightMiddle.style.height = (currentHeatmap.timeSquareRowsCount - y2 - 1) * sqPx + px + 'px';
			rightMiddle.style.display = 'block';

			right.style.left = veryEndX + 'px';
			right.style.top = topPadding + 'px';
			right.style.width = sqPx + px + 'px';
			right.style.height = (y2 + 1) * sqPx + px + 'px';
			right.style.display = 'block';

			if (x2 - x1 === 1) {
				middle.style.display = 'none';
			} else {
				middle.style.left = veryStartX + sqPx + px + 'px';
				middle.style.top = topPadding + 'px';
				middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
				middle.style.height = currentHeatmap.timeSquareRowsCount * sqPx + px + 'px';
				middle.style.display = 'block';
			}
		}
	}

	function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
		if (ctrlPressed) {
			highlightStart = sample;
			highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
		} else if (shiftPressed && heatActiveSample1 !== -1) {
			highlightStart = Math.min(heatActiveSample1, sample);
			highlightEnd = Math.max(heatActiveSample1, sample);
		} else {
			highlightStart = highlightEnd = sample;
		}

		callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

		const index = (sample - currentHeatmap.startBlock()) * currentHeatmap.timeSquareScale;
		const counts = currentHeatmap.blocksData.counts;
		const foundCounts = currentHeatmap.blocksData.foundCounts;
		if (index >= 0 && index < counts.length) {
			const countBeforeFirstBlock = getCount(counts, index - 1);
			const countAtLastBlock = getCount(counts, index + currentHeatmap.timeSquareScale - 1);
			const searchCountBeforeFirstBlock = getCount(foundCounts, index - 1);
			const searchCountAtLastBlock = getCount(foundCounts, index + currentHeatmap.timeSquareScale - 1);

			const total = countAtLastBlock - countBeforeFirstBlock;
			const searchTotal = searchCountAtLastBlock - searchCountBeforeFirstBlock;
			const max = currentHeatmap.max(false);
			const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
			const searchText = showFound
				? "; match: " + searchTotal + " (" + Math.floor(searchTotal / Math.max(currentHeatmap.max(true), 1) * 100) + "%)"
				: "";
			status.textContent = totalText + searchText;
			status.style.display = 'inline';
		} else {
			status.style.display = 'none';
		}
		const ms = Math.floor(startMs / currentHeatmap.currentTimeSquareMs()) * currentHeatmap.currentTimeSquareMs() + currentHeatmap.minimalTimeSquare * index;
		heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort);
	}

	function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
		if (ctrlPressed) {
			let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
			let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

			heatDiffSample1 = highlightStart;
			heatDiffSample2 = highlightEnd;

			callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
			renderWrapperDiff(
				(minSelected - currentHeatmap.startBlock()) * currentHeatmap.timeSquareScale,
				(maxSelected - currentHeatmap.startBlock() + 1) * currentHeatmap.timeSquareScale - 1,
				(heatDiffSample1 - currentHeatmap.startBlock()) * currentHeatmap.timeSquareScale,
				(heatDiffSample2 - currentHeatmap.startBlock() + 1) * currentHeatmap.timeSquareScale - 1
			);
		} else {
			heatDiffSample1 = -1;
			heatDiffSample2 = -1;
			if (shiftPressed && heatActiveSample1 !== -1) {
				heatActiveSample2 = sample;
			} else {
				heatActiveSample1 = heatActiveSample2 = sample;
			}

			let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
			let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

			callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
			callHighlightRedraw(minSelected, maxSelected, 'Active');
			renderWrapper(
				(minSelected - currentHeatmap.startBlock()) * currentHeatmap.timeSquareScale,
				(maxSelected - currentHeatmap.startBlock() + 1) * currentHeatmap.timeSquareScale - 1
			);
		}
	}

	function updateSelectionArea(delta, endOnly, diff) {
		highlightStart = -1;
		highlightEnd = -1;
		if (diff) {
			if (heatDiffSample1 === -1) {
				let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
				let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);
				heatDiffSample1 = minSelected + delta;
				heatDiffSample2 = maxSelected + delta;
			} else {
				if (!endOnly) {
					heatDiffSample1 += delta;
				}
				heatDiffSample2 += delta;
			}
			let min = Math.min(heatDiffSample1, heatDiffSample2);
			let max = Math.max(heatDiffSample1, heatDiffSample2);
			callHighlightRedraw(min, max, 'Diff');
		} else {
			if (!endOnly) {
				heatActiveSample1 += delta;
			}
			heatActiveSample2 += delta;
			let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
			let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

			callHighlightRedraw(minSelected, maxSelected, 'Active');
			callHighlightRedraw(highlightStart, highlightEnd, 'Selection');
			if (heatDiffSample1 === -1) {
				callHighlightRedraw(minSelected, maxSelected, 'Diff');
			}
		}
		let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
		let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

		if (heatDiffSample1 === -1) {
			renderWrapper(
				(minSelected - currentHeatmap.startBlock()) * currentHeatmap.timeSquareScale,
				(maxSelected - currentHeatmap.startBlock() + 1) * currentHeatmap.timeSquareScale - 1
			);
		} else {
			let min = Math.min(heatDiffSample1, heatDiffSample2);
			let max = Math.max(heatDiffSample1, heatDiffSample2);
			renderWrapperDiff(
				(minSelected - currentHeatmap.startBlock()) * currentHeatmap.timeSquareScale,
				(maxSelected - currentHeatmap.startBlock() + 1) * currentHeatmap.timeSquareScale - 1,
				(min - currentHeatmap.startBlock()) * currentHeatmap.timeSquareScale,
				(max - currentHeatmap.startBlock() + 1) * currentHeatmap.timeSquareScale - 1
			);
		}
	}

	window.addEventListener('keydown', e => {
		if (e.key === 'Shift') {
			callSelectionRedraw(heatLastSample, true, e.ctrlKey);
		} else if (e.key === 'Control') {
			callSelectionRedraw(heatLastSample, e.shiftKey, true);
		}
	});

	window.addEventListener('keyup', e => {
		if (e.key === 'Shift') {
			callSelectionRedraw(heatLastSample, false, e.ctrlKey);
		} else if (e.key === 'Control') {
			callSelectionRedraw(heatLastSample, e.shiftKey, false);
		}
	});

	window.addEventListener('keydown', e => {
		switch (e.key) {
			case 'ArrowUp':
				updateSelectionArea(-1, e.shiftKey, e.ctrlKey);
				break;
			case 'ArrowDown':
				updateSelectionArea(+1, e.shiftKey, e.ctrlKey);
				break;
			case 'ArrowLeft':
				updateSelectionArea(-currentHeatmap.timeSquareRowsCount, e.shiftKey, e.ctrlKey);
				break;
			case 'ArrowRight':
				updateSelectionArea(+currentHeatmap.timeSquareRowsCount, e.shiftKey, e.ctrlKey);
				break;
			case '1':
				selectMode('flame-mode-flame');
				break;
			case '2':
				selectMode('flame-mode-reversed');
				break;
			case '3':
				selectMode('flame-mode-methods');
				break;
			case 'r':
			case 'R':
				if (!e.ctrlKey) {
					return;
				}
				if (heatDiffSample1 !== -1) {
					renderWrapperDiff(lastBaseRenderFrom, lastBaseRenderTo, lastRenderFrom, lastRenderTo);
				}
				break;
			case 'f':
			case 'F':
				if (!e.ctrlKey) {
					return;
				}
				search(true, e.shiftKey);
				break;
			case 'Escape':
				search(false);
				break;
			default:
				return;
		}
		e.preventDefault();
	});

	window.onkeydown = function (e) {
		if (e.keyCode === 16) {
			if (previewX !== -1 && previewY !== -1) {
				showPreview();
			}
		}
	}

	window.onkeyup = function (e) {
		if (!e.shiftKey) {
			preview_wrapper.style.display = 'none';
		}
	}

	let moved = false;
	heatCanvas.onmousemove = function (event) {
		let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
		let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
		if (y >= currentHeatmap.timeSquareRowsCount) {
			y = currentHeatmap.timeSquareRowsCount - 1;
		}
		heatLastSample = x * currentHeatmap.timeSquareRowsCount + y;
		if ((event.buttons & 1) === 1) {
			callSelectionRedraw(heatLastSample, true, event.ctrlKey);
		} else {
			callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
		}
		moved = true;
	}

	heatCanvas.onmouseout = function () {
		status.style.display = 'none';
	};

	heatCanvas.onmousedown = function (event) {
		let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
		let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
		let sample = x * currentHeatmap.timeSquareRowsCount + y;

		callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
		moved = false;
	};

	heatCanvas.onmouseup = function (event) {
		if (moved) {
			let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
			let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
			let sample = x * currentHeatmap.timeSquareRowsCount + y;

			callActiveRedraw(sample, true, event.ctrlKey);
		}
	};

	renderHeatmap();
	// first render of dominators
	renderFunc = renderTraces;
</script>
</body>
</html>
